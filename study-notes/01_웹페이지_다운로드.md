# 웹페이지 다운로드

## 1.1 서버에 연결하기

### URL

http://example.org/index.html

- http(스킴) - 어떻게 정보에 접글할 수 있는지 설명
- example.org(호스트) - 어디에서 정보를 얻을 수 있는지 설명
- index.html(경로) - 무슨 정보를 얻을 것인지 설명
- 포트, 쿼리, 프래그먼트 등

> #### [!NOTE] URL이 주어지면 브라우저가 웹페이지를 다운로드 하는 과정
>
> 1. 브라우저는 운영체제에 호스트 이름에 해당하는 서버와 연결해달라고 요청
> 2. 운영체제는 DNS서버와 통신해 호스트 이름을 IP주소로 변환
> 3. 라우팅 테이블을 사용해 해당 IP주소와 가장 적합한 장치를 결정하고 장치 드라이버를 사용해 신호를 보냄
> 4. 라우터는 신호를 감지하고 다음 라우터로 전송
> 5. 메시지가 서버에 도착하면 해당 서버와의 연결

> #### [!QUESTION] REST API와 웹의 탈중앙화 무슨 연관이 있는가?
>
> **개인적 관점**:
> **인터페이스**가 가장 핵심적인 역할을 한 것 같다.
> HTTP 메서드와 상태 코드를 표준처럼 적용함으로써, 다른 사이트들도 해당 방식을 채택하게 되었고,
> 이로 인해 탈중앙화가 되면서도 모든 브라우저에서 사용 가능한 웹페이지를 만들 수 있게된?
>
> **Claude의 관점**:
> 통합 인터페이스가 핵심이라는 관점에 동의한다. 특히 **네트워크 효과**가 중요했다고 본다.
> 한 사이트가 HTTP 표준을 사용하면 → 더 많은 클라이언트가 접근 가능 → 다른 사이트들도 동일한 표준 채택 →
> 전체 생태계가 강화되는 선순환이 만들어졌다.
> 또한 **Stateless 특성**도 중요한데, 서버가 클라이언트 상태를 기억할 필요가 없어서
> 확장성과 장애 복구가 쉬워진 점도 탈중앙화에 기여했다고 생각한다.

## 1.2 정보 요청하기

- 연결이 되고나면 브라우저는 /index.html처럼 호스트명 뒤에 오는 URL의 경로에 해당하는 정보를 요청

![MDN HTTP request](https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-request.svg)

- 마지막 헤더가 끝나면 호스트에 헤더가 끝났음을 알려주는 빈 줄이 하나 필요

## 1.3 서버의 응답

![MDN HTTP request](https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-response.svg)

### 상태코드

- 100 번대: 정보 메시지
- 200 번대: 성공
- 300 번대: 후속 작업 필요
- 400 번대: 잘못된 요청
- 500 번대: 서버 에러

### 응답 헤더

- 요청하는 정보 관련: Content-Type, Content-Length, Last-Modified
- 서버에 관한 정보: Server, X-Cache
- 캐시 조건: Cache-Control, Expires, Etag

## 1.4 파이썬을 통한 텔넷

- 웹페이지를 다운로드하는 첫 번째 단계는 호스트에 연결하는 것이다. 운영체제에서는 이를 위해 **소켓**이라는 기능을 제공

### 소켓(Socket)을 통한 연결

**소켓**은 네트워크를 통해 데이터를 주고받기 위한 **통신 엔드포인트(endpoint)**입니다. 마치 전화기의 수화기처럼, 두 컴퓨터가 대화하기 위한 "연결점"

#### 소켓의 개념적 이해

**추상화 계층**: 소켓은 복잡한 네트워크 통신을 **파일 입출력처럼 간단하게** 만들어준다.

```python
# 파일 읽기와 비슷함
file = open('data.txt', 'r')
data = file.read()

# 소켓 통신도 비슷함
socket = socket.connect('example.org', 80)
data = socket.recv()
```

**양방향 통신**: 소켓은 **양방향 파이프**와 같습니다:

- 클라이언트 → 서버: 요청 전송
- 서버 → 클라이언트: 응답 전송
- 동시에 데이터를 주고받을 수 있음

#### 소켓의 구성 요소

```
Socket = IP 주소 + 포트 번호
예: 192.168.1.100:8080
```

#### 소켓의 타입

**TCP 소켓 (SOCK_STREAM)**:

```
특징: 연결 지향, 신뢰성, 순서 보장
비유: 전화 통화 (연결 후 대화)

[Client] ←→ [연결 설정] ←→ [Server]
         ←→ [데이터 전송] ←→
         ←→ [연결 종료] ←→
```

**UDP 소켓 (SOCK_DGRAM)**:

```
특징: 비연결 지향, 빠름, 순서 보장 없음
비유: 편지 (그냥 보냄, 도착 보장 안됨)

[Client] → [데이터그램] → [Server]
```

#### 소켓 통신 과정 (TCP 기준)

**1. 소켓 생성**:

```python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

**매개변수 설명**:

- `AF_INET`: Address Family - IPv4 인터넷 프로토콜 사용
- `AF_INET6`: IPv6 인터넷 프로토콜 사용
- `AF_UNIX`: 유닉스 도메인 소켓 (같은 시스템 내 프로세스 간 통신)
- `SOCK_STREAM`: TCP 소켓 (연결 지향, 신뢰성)
- `SOCK_DGRAM`: UDP 소켓 (비연결 지향, 빠름)

**2. 연결 설정 (3-way Handshake)**:

```python
s.connect(('example.org', 80))
```

```
Client                    Server
   |                         |
   |-------- SYN ----------->|  (연결 요청)
   |<----- SYN-ACK ----------|  (연결 수락)
   |-------- ACK ----------->|  (연결 확인)
   |                         |
   |<===== 연결 성공 ==========|
```

## 1.5 요청과 응답

- 데이터를 주고 받을 때, 비트나 바이트로 이루어진 데이터를 주고 받는다.
  - 그래서 문자열을 바이트로 변환하는 `encode` 사용이 필요

> ### [!NOTE] HTTP 압축 관련 헤더들
>
> #### Accept-Encoding (요청 헤더)
>
> 클라이언트가 지원하는 압축 방식을 서버에 알려줌
>
> ```
> Accept-Encoding: gzip, deflate, br
> ```
>
> #### Content-Encoding (응답 헤더)
>
> 서버가 실제로 사용한 압축 방식을 클라이언트에 알려줌
>
> ```
> Content-Encoding: gzip
> ```
>
> #### Transfer-Encoding (응답 헤더)
>
> 데이터 전송 방식 (주로 청크 단위 전송)
>
> ```
> Transfer-Encoding: chunked
> ```
>
> #### 주요 압축 방식
>
> - **gzip**: 가장 널리 사용되는 압축 방식 (GNU zip, 1992년)
> - **deflate**: zlib 압축 방식 (1996년)
> - **br**: Brotli 압축 (Google 개발, 2015년, 높은 압축률)
> - **zstd**: Zstandard 압축 (Facebook 개발, 2016년, 빠른 속도)
> - **compress**: 구식 LZW 압축 (거의 사용 안함)
>
> #### 압축 효과
>
> - **텍스트 파일**: 70-90% 압축률 (HTML, CSS, JS)
> - **이미지**: 이미 압축된 형태라 효과 적음
> - **네트워크 대역폭**: 크게 절약, 로딩 속도 향상

## 1.6 HTML 표시하기

- html은 tag와 text로 구성

## 1.7 암호화된 연결

- https 스킴은 브라우저와 호스트 간의 모든 통신이 암호화

> [!NOTE] HTTPS와 TLS 보안 계층
>
> ### HTTP vs HTTPS
>
> - **HTTP**: 평문 통신 (포트 80)
> - **HTTPS**: 암호화된 통신 (포트 443)
>
> ### TLS (Transport Layer Security)
>
> HTTP와 TCP 사이에 위치하는 보안 계층
>
> ```
> Application Layer: HTTP
>        ↓
> Security Layer:    TLS/SSL
>        ↓
> Transport Layer:   TCP
>        ↓
> Network Layer:     IP
> ```
>
> ### TLS Handshake 과정
>
> ```
> Client                    Server
>    |                         |
>    |--- Client Hello ------->|  (지원 암호화 방식 전송)
>    |<-- Server Hello --------|  (선택된 암호화 방식)
>    |<-- Certificate ---------|  (서버 인증서)
>    |--- Key Exchange ------>|  (암호화 키 교환)
>    |<-- Finished ------------|  (핸드셰이크 완료)
>    |                         |
>    |<== 암호화된 HTTP 통신 ==|
> ```
>
> ### 암호화 방식
>
> **대칭키 암호화**:
>
> - 같은 키로 암호화/복호화
> - 빠른 속도, 대용량 데이터에 적합
> - 문제: 키를 안전하게 전달하는 방법?
>
> **비대칭키 암호화 (공개키)**:
>
> - 공개키로 암호화, 개인키로 복호화
> - 안전한 키 교환 가능
> - 문제: 느린 속도, 대용량 데이터에 부적합
>
> ### TLS의 하이브리드 방식
>
> ```
> 1. 비대칭키로 대칭키 전달
>    Client --[대칭키를 공개키로 암호화]--> Server
>
> 2. 이후 대칭키로 모든 데이터 암호화
>    Client <--[빠른 대칭키 암호화 통신]--> Server
> ```
>
> **장점**: 보안성(비대칭키) + 속도(대칭키) 모두 확보
>
> ### 주요 보안 기능
>
> - **암호화**: 데이터 내용을 제3자가 읽을 수 없게 함
> - **무결성**: 데이터가 전송 중 변조되지 않았음을 보장
> - **인증**: 서버가 실제 해당 사이트임을 증명
> - **전방향 보안**: 과거 통신이 미래 키 노출로 해독되지 않음

## 연습문제

### 1-7 Keep-Alive

[Keep-Alive](bonus-notes/keep-alive.md)
