# 텍스트 포맷팅하기

## 3.1 폰트(서체)란?

- 과거 금속 활자는 글자마다 별도의 케이스에 모았다. 케이스들의 집합을 **폰트**라고 했고 폰트의 집합을 **타입**이라고 불렀다. **타이핑**이라는 말이 이 타입에서 유래됐다. 글자의 굵기나 기울기 같은 변형은 타입의 **페이스**라고 불렀다.
- 오늘날의 폰트는 글꼴, 서체, 타입을 의미(스타일, 크기)

## 3.2 텍스트 측정하기

![타이포그래피](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT9HgUs2vABYZojGmqrzohMk7PFtFhIIhY6Ew&s)

### 글리프 (Glyph)

**글리프**는 폰트에서 하나의 시각적 문자 단위 (폰트 파일 안에 들어있는 개별 글자 하나하나)

### 기준선 (Baseline)

**기준선**은 글자가 서 있는 가상의 수평선

### 어센트 (Ascent)

**어센트**는 기준선에서 위쪽으로 올라가는 부분

- 영문 소문자 중 'b', 'd', 'h', 'k', 'l' 같은 글자들이 위로 올라가는 부분
- 대문자의 높이
- 기준선부터 글자가 올라갈 수 있는 최대 높이까지의 영역

### 디센트 (Descent)

**디센트**는 기준선 아래로 내려가는 부분

- 영문 소문자 중 'g', 'j', 'p', 'q', 'y' 같은 글자들이 아래로 내려가는 부분
- 기준선 아래 영역의 깊이

### 추가 용어들

- **x-높이 (x-height)**: 소문자 'x'의 높이로, 기준선에서 소문자의 상단까지의 높이로 어센더가 없는 일반 소문자의 높이
- **캡 높이 (Cap height)**: 대문자의 높이로, 기준선에서 대문자 상단까지의 거리
- **라인 갭 (Line gap)**: 한 줄의 디센트와 다음 줄의 어센트 사이의 간격

## 3.3 한 단어씩 처리하기

- 영어는 단어 중간에 다음 줄로 이동할 수 없고 텍스트를 한 번에 한 단어씩 배치

### 하이픈 연결이란?

줄 끝에서 단어가 다 들어가지 않을 때, 단어를 **음절 단위로 나누고 하이픈(-)을 붙여** 다음 줄로 넘기는 기법

```
This is a very long sen-
tence with more comfort-
able spacing.
```

**목적**: 가독성 향상, 정렬 개선, 공간 효율 증대

#### Knuth-Liang 알고리즘

**Donald Knuth**와 **Frank Liang**이 개발한 하이픈 연결 알고리즘입니다.

**특징**:

- TeX 조판 시스템에서 개발됨
- 패턴 매칭 방식으로 음절 경계를 자동 감지
- 사전 없이도 높은 정확도
- 현대 브라우저들이 내부적으로 사용하는 기술

#### CSS: hyphens 속성

**[MDN 문서: hyphens](https://developer.mozilla.org/en-US/docs/Web/CSS/hyphens)**

단어를 **어떻게 나눌 것인가**를 제어합니다.

```css
p {
  hyphens: none; /* 하이픈 연결 사용 안 함 */
  hyphens: manual; /* &shy; 위치에만 적용 */
  hyphens: auto; /* 자동으로 적용 (Knuth-Liang 활용) */
}
```

**사용 예시**:

```css
/* 본문: 자동 하이픈 */
p {
  hyphens: auto;
  lang: "en"; /* 언어 지정 필요 */
}

/* 제목: 하이픈 없이 */
h1,
h2 {
  hyphens: none;
}
```

## 3.6 다양한 크기의 텍스트

### 텍스트 베이스라인 계산의 투패스 알고리즘

#### 왜 투패스가 필요한가?

한 줄에 **서로 다른 폰트, 크기, 스타일이 혼합**되어 있을 때, 모든 요소의 정보를 **먼저 알아야** 올바른 베이스라인을 계산할 수 있기 때문입니다.

**예시 상황**:

```html
<p>일반 텍스트 <span style="font-size: 32px">큰 글씨</span><sub>아래첨자</sub></p>
```

이 한 줄에는:

- 일반 크기 텍스트
- 큰 글씨 (더 높은 어센트 필요)
- 아래첨자 (베이스라인 아래로)

**문제**: 큰 글씨 때문에 전체 줄 높이가 달라져야 하는데, 이걸 처음부터 알 수 없습니다!

#### 투패스 알고리즘 과정

**첫 번째 패스 (First Pass): 정보 수집**

한 줄의 모든 요소를 순회하며 메트릭을 수집합니다.

**수집하는 정보**:

- 각 요소의 어센트 (위로 올라가는 높이)
- 각 요소의 디센트 (아래로 내려가는 높이)
- 폰트 크기
- `vertical-align` 값
- 이미지/인라인 블록의 높이

**두 번째 패스 (Second Pass): 실제 배치**

첫 패스에서 계산된 정보를 바탕으로 각 요소를 정확한 위치에 배치합니다.

#### 구체적인 예시

```html
<p>Normal <span style="font-size: 40px">Big</span> text</p>
```

**First Pass**:

```
Normal: ascent=12px, descent=4px, fontSize=16px
Big:    ascent=32px, descent=8px, fontSize=40px

line-height 계산:
Normal: 16px × 1.5 = 24px
Big:    40px × 1.5 = 60px

최종: maxLineHeight = 60px
```

**Second Pass**:

```
Big의 메트릭:
  폰트 높이: 32 + 8 = 40px
  줄 높이: 60px
  리딩: 60 - 40 = 20px
  half-leading: 10px

베이스라인 위치 = 10px(half-leading) + 32px(ascent) = 42px
```

**베이스라인 공식**

```
half-leading = (line-height - (ascent + descent)) / 2
베이스라인 위치 = half-leading + maxAscent
줄 전체 높이 = line-height 값
```

#### 복잡한 케이스: vertical-align

```html
<p>
  Text <span style="vertical-align: super">위첨자</span>
  <img style="vertical-align: middle" />
</p>
```

**First Pass**로 전체 높이를 알아야:

- `super`가 얼마나 위로 올라갈지
- `middle`이 중앙 어디인지
- 전체 줄이 얼마나 높아질지를 계산할 수 있습니다.

#### 정리

**원패스 시도**:

```
"Normal" 렌더링 → 베이스라인 12px
"Big" 발견 → 어? 32px 필요함!
→ "Normal"을 다시 아래로 내려야 함 (이미 그렸는데!)
```

결국 **다시 계산**해야 하므로, 처음부터 투패스로 설계하는 것이 효율적입니다.

**투패스가 필요한 이유**:

- 한 줄의 최종 높이는 **가장 큰 요소**에 의해 결정됨
- 모든 요소를 봐야 누가 가장 큰지 알 수 있음
- 베이스라인은 이 최종 높이를 기준으로 계산됨

**결과**:

- 다양한 크기와 스타일이 혼합된 텍스트도 정확하게 정렬
- `vertical-align` 같은 복잡한 속성도 올바르게 동작

## 3.7 텍스트 캐싱

### 비례글꼴 (Proportional Font)

![Proportional Font](https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Proportional-vs-monospace-v5.svg/500px-Proportional-vs-monospace-v5.svg.png)

**비례글꼴**: 글자마다 **너비가 다름**

예: Arial, 맑은 고딕 (일반 문서용)

**장점**: 자연스럽고 읽기 편함, 공간 효율적
**사용처**: 책, 웹사이트, 일반 문서

### 힌팅 (Hinting)

![Hinting](https://alistapart.com/wp-content/uploads/2015/04/Georgia-hinted_outlines.svg)

> _<small>오른쪽이 힌팅된 이미지라고 하는데 이게 더 선명하게보이는게 맞는지 모르겠다?</small>_

**문제**: 작은 크기에서 글자가 흐릿하거나 찌그러져 보임

**해결**: 픽셀 격자에 맞춰 글자 모양을 **미세하게 조정**하는 정보

**예시**:

```
힌팅 없음:          힌팅 있음:
●●○○              ●●●●
●○○●              ●●●●
●●○○              ●●●●
(흐릿함)            (선명함)
```

**비유**: 작은 화면에서 글자를 선명하게 보이도록 "픽셀에 맞춰 살짝 당기고 미는" 작업

**중요한 이유**:

- 작은 폰트 크기 (12px, 14px)에서 가독성 향상
- 저해상도 모니터에서 특히 중요
- 고해상도(레티나) 디스플레이에서는 덜 중요

**CSS**:

```css
p {
  font-smooth: antialiased; /* macOS */
  -webkit-font-smoothing: antialiased;
}
```

#### 커닝 (Kerning)

![Kerning](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Kerning_EN.svg/250px-Kerning_EN.svg.png)

**문제**: 글자 조합에 따라 간격이 어색해 보임

**해결**: 특정 글자 쌍의 간격을 **개별적으로 조정**

**자간(Tracking)과의 차이**:

- **커닝**: 특정 글자 **쌍**의 간격 (AV, To, We)
- **자간**: **모든** 글자의 간격을 일괄 조정

**CSS에서**:

```css
h1 {
  font-kerning: auto; /* 커닝 활성화 */
}
```
