# 개발자 스타일 적용하기

## 6.1 함수를 사용한 파싱

- style 어트리뷰트 - ';'을 구분자로 사용하여 여러 쌍의 프로퍼티와 값을 지정

```python

class CSSParser:
  def __init__(self, s):
      self.s = s
      self.i = 0

```

```python

  def whitespace(self):
        while self.i < len(self.s) and self.s[self.i].isspace():
            self.i += 1

```

- `whitespace`는 의미가 없으므로 파싱된 데이터를 반환X
- CSS파서가 해당 라인을 읽었음을 체크하기 위한 인덱스만 증가

```python

  def word(self):
      start = self.i
      while self.i < len(self.s):
          if self.s[self.i].isalnum() or self.s[self.i] in "#-.%": # 알파벳/숫자 이거나 "#-.%" 이거나
              self.i += 1
          else:
              break
      if not (self.i > start):
          raise Exception("Parsing error")
      return self.s[start:self.i]

```

- `word`는 시작 위치를 저장했다가 이동한만큼의 부분 문자열을 반환
- `self.i`가 한 번도 증가하지 않은 경우(처음부터 word가 아닌 경우)는 예외를 발생
- 실제 브라우저는 프로퍼티와 값은 문법이 다르기 때문에 `word`처럼 단순하지 않음

```python

  def literal(self, literal):
    if not (self.i < len(self.s) and self.s[self.i] == literal):
        raise Exception("Parsing error")
    self.i += 1

```

- ':'이나 다른 구분자 확인 시 사용

```python

  def pair(self):
      prop = self.word()
      self.whitespace()
      self.literal(":")
      self.whitespace()
      val = self.word()
      return prop.casefold(), val

```

- 파싱 함수의 장점은 만들어진 함수를 이용해 다른 함수를 구축할 수 있다는 점
- 하나의 프로퍼티와 값에 대한 처리 ex) `font-size: 16px`
  1. prop = self.word() → "font-size"
  2. self.whitespace() → 공백 건너뜀
  3. self.literal(":") → : 문자 확인 및 위치 이동
  4. self.whitespace() → 공백 건너뜀
  5. val = self.word() → "16px"
  6. 반환: ("font-size", "16px")

```python
  def body(self):
      pairs = {}
      while self.i < len(self.s):
          try:
              prop, val = self.pair()
              pairs[prop.casefold()] = val # 소문자 변경을 중복으로?
              self.whitespace()
              self.literal(";")
              self.whitespace()
          except Exception:
              why = self.ignore_until([";"])
              if why == ";":
                  self.literal(";")
                  self.whitespace()
              else:
                  break
      return pairs

```

- 루프를 돌며 파싱 함수를 호출해 시퀀스를 파싱
  > ⁉️ 시퀀스는 순서가 있는 데이터 집합으로 알고 있는데 파이썬의 딕셔너리는 논시퀀스 아닌가? 파싱 함수를 돌면서 동일한 프로퍼티가 나올 시 가장 후순위의 값으로 덮어쓰기에 순서가 있는 개념으로 시퀀스를 쓴 것인가?
- 예외가 발생하면 ';'이나 '}'로 건너뜀

```python
  def ignore_until(self, chars):
      while self.i < len(self.s):
          if self.s[self.i] in chars:
              return self.s[self.i]
          else:
              self.i += 1
      return None
```

- 주어진 문자열이 나올 때 까지 인덱스만 증가시키고 나오면 주어진 문자 반환, 파일 끝에서 멈춘 경우는 None 반환
- 브라우저는 개발자의 실수 / 특정 브라우저의 기능에 따라 다르기 때문에 오류 처리에 대한 고민이 중요
- 파싱이 되지 않는 프로퍼티-값 쌍은 건너뛰고 파싱 가능한 프로퍼티-값 쌍은 유지
- 파싱을 건너뜀으로써 오류 메세지를 숨기므로 디버깅이 어려워지지만 브라우저에 따라 다르게 동작될 수 있기에 이해하지 못한 내용은 사일런트 파싱에러로 그냥 무시

## 6.2 style 어트리뷰트

```python

def style(node):
    node.style = {}
    if isinstance(node, Element) and "style" in node.attributes:
        pairs = CSSParser(node.attributes["style"]).body()
        for property, value in pairs.items():
            node.style[property] = value

    for child in node.children:
        style(child)

```

- style 어트리뷰트를 파싱해 노드의 style 필드에 저장하는 style 함수
- HTML 트리를 재귀적으로 순회하여 각 엘리먼트에 스타일 지정

```python
class Browser:
    def load(self, url):
        body = url.request()
        self.nodes = HTMLParser(body).parse()

        style(self.nodes)

        self.document = DocumentLayout(self.nodes)
        self.document.layout()
        self.display_list = []
        paint_tree(self.document, self.display_list)
        self.draw()

```

- 레이아웃 수행 전 style을 호출하여 각 style이 적용된 상태로 크기나 위치를 계산할 수 있도록 함

```python
class BlockLayout:
  def paint(self):
      cmds = []
      bgcolor = self.node.style.get("background-color",
                                    "transparent")
      if bgcolor != "transparent":
          x2, y2 = self.x + self.width, self.y + self.height
          rect = DrawRect(self.x, self.y, x2, y2, bgcolor)
          cmds.append(rect)

```

- 초기 브라우저는 각 엘리먼트에 style 어트리뷰트를 설정하는 불편한 방법이였음
- 개선을 위해 CSS 등장
  - 하나의 CSS 파일로 많은 페이지의 스타일을 일관되게 적용
  - 한 줄의 CSS로 한 번에 많은 엘리먼트의 스타일을 일관되게 적용
  - 미래해도 변함 없이 사용 가능, 다양한 기능으로 브라우저 지원
- CSS 셀렉터와 캐스케이딩으로 style 어트리뷰트 확장
  - 셀렉터는 프로퍼티-값 쌍들의 리스트가 적용되는 HTML 엘리먼트를 정의
  - Rule - 엘리먼트 + 프로퍼티-값 쌍
  ```css
  main p {
    font-size: 20px;
  }
  ```

## 6.3 셀렉터

```python

class TagSelector:
    def __init__(self, tag):
        self.tag = tag

    def matches(self, node):
        return isinstance(node, Element) and self.tag == node.tag

class DescendantSelector:
    def __init__(self, ancestor, descendant):
        self.ancestor = ancestor
        self.descendant = descendant

    def matches(self, node):
        if not self.descendant.matches(node): return False
        while node.parent:
            if self.ancestor.matches(node.parent): return True
            node = node.parent
        return False

```

- 셀렉터 클래스는 각 엘리먼트가 매치되는지 판단하는 함수를 가짐
- 자손셀렉터의 두 필드는 자체도 셀렉터이며 재귀적으로 매치되는지 판단

```python

class CSSParser:
    def selector(self):
        out = TagSelector(self.word().casefold())
        self.whitespace()
        while self.i < len(self.s) and self.s[self.i] != "{":
            tag = self.word()
            descendant = TagSelector(tag.casefold())
            out = DescendantSelector(out, descendant)
            self.whitespace()
        return out

```

- 선택자 부분을 루프를 돌면서 자손 선택자가 있는 경우에 자손 선택자로 변경

```python

    def parse(self):
        rules = []
        while self.i < len(self.s):
            try:
                self.whitespace()
                selector = self.selector()
                self.literal("{")
                self.whitespace()
                body = self.body()
                self.literal("}")
                rules.append((selector, body))
            except Exception:
                why = self.ignore_until(["}"])
                if why == "}":
                    self.literal("}")
                    self.whitespace()
                else:
                    break
        return rules

   def body(self):
            except Exception:
                why = self.ignore_until([";", "}"])
                if why == ";":
                    self.literal(";")
                    self.whitespace()
                else:
                    break

```

- 셀렉터와 프로퍼티-값 으로 이루어진 rules 반환
- `body`에서 '}'을 만나면 중단
- 파싱 에러시 '}' 가 나올 때 까지 건너띄기

> 퍼징? 나중에 학습

## 6.4 스타일시트 적용하기

```python

def style(node, rules):

    for selector, body in rules:
        if not selector.matches(node): continue
        for property, value in body.items():
            node.style[property] = value

    if isinstance(node, Element) and "style" in node.attributes:
        pairs = CSSParser(node.attributes["style"]).body()
        for property, value in pairs.items():

```

- style 어트리뷰트를 파싱하기 전에 CSS 파일을 파싱한 스타일 적용 (CSS 우선순위)

```python

DEFAULT_STYLE_SHEET = CSSParser(open("browser.css").read()).parse()

class Browser:
    def load(self, url):
        rules = DEFAULT_STYLE_SHEET.copy()
        style(self.nodes, rules)
```

- 브라우저에서 정의한 기본 스타일 시트 (유저 에이전트 스타일시트)

```python

def tree_to_list(tree, list):
    list.append(tree)
    for child in tree.children:
        tree_to_list(child, list)
    return list

```

- 트리를 리스트로 변경하는 헬퍼 함수 (DFS)

```python

class Browser:


    def load(self, url):
        links = [node.attributes["href"]
                 for node in tree_to_list(self.nodes, [])
                 if isinstance(node, Element)
                 and node.tag == "link"
                 and node.attributes.get("rel") == "stylesheet"
                 and "href" in node.attributes]

```

- `<link rel="stylesheet" href="css경로" />` 형태의 태그 리스트 할당
- 스타일시트 URL은 일반적으로 상대 URL

  1. 호스트 렐러티브 (Host-relative)

  - **형식**: `/path`
  - **예시**: `<link href="/styles/main.css">`
  - **해석**: 호스트 루트부터 시작 → `https://example.com/styles/main.css`
  - **특징**: 현재 페이지 위치와 무관, 사이트 구조 변경에 안전 (권장)

  2. 경로 렐러티브 (Path-relative)

  - **형식**: `path`, `./path`, `../path`
  - **예시**: `<link href="../styles/main.css">`
  - **해석**: 현재 페이지 디렉토리 기준 → `../`는 상위 디렉토리로 이동
  - **특징**: 페이지 위치에 종속적, 디렉토리 구조 변경 시 주의

  3. 스킴 렐러티브 (Scheme-relative)

  - **형식**: `//host/path`
  - **예시**: `<link href="//cdn.example.com/styles/main.css">`
  - **해석**: 현재 페이지의 프로토콜(http/https) 상속
  - **특징**: CDN 리소스에 주로 사용, HTTP/HTTPS 자동 매칭

```python

class URL:
    def resolve(self, url):
        if "://" in url: return URL(url)
        if not url.startswith("/"):
            dir, _ = self.path.rsplit("/", 1)
            while url.startswith("../"):
                _, url = url.split("/", 1)
                if "/" in dir:
                    dir, _ = dir.rsplit("/", 1)
            url = dir + "/" + url
        if url.startswith("//"):
            return URL(self.scheme + ":" + url)
        else:
            return URL(self.scheme + "://" + self.host + \
                       ":" + str(self.port) + url)

```

- 상대 URL을 전체 URL로 변환

```python

class Browser:
    def load(self, url):
        for link in links:
            style_url = url.resolve(link)
            try:
                body = style_url.request()
            except:
                continue
            rules.extend(CSSParser(body).parse())

```

- 연결된 링크들을 절대URL로 변경하여 요청 후 받아온 문자열을 CSSParser를 통해 파싱 후 rules 추가

## 6.5 캐스케이딩

- 하나의 엘리먼트에 여러 규칙이 적용될 수 있기때문에 규칙의 순서가 중요
- 올바른 규칙의 순서를 **캐스케이드 오더**라고 하며, 규칙의 셀렉터를 기반으로 하되 우선순위가 같은 경우 파일의 순서도 참고
  - 구체적인 규칙일수록 우선순위가 높다.

```python

class TagSelector:
    def __init__(self, tag):
        self.priority = 1

class DescendantSelector:
    def __init__(self, ancestor, descendant):
        self.priority = ancestor.priority + descendant.priority

def cascade_priority(rule):
    selector, body = rule
    return selector.priority

class Browser:
    def load(self, url):
        style(self.nodes, sorted(rules, key=cascade_priority))
```

- priority로 캐스케이드 오더 표현
- style 호출 시 priority 기준으로 정렬

## 6.6 상속된 스타일

- CSS에서 텍스트 스타일이 동작하는 방식이 상속이다. 상속은 부모 노드의 값을 대신 사용하는 것을 의미
  - 상속이 되는 프로퍼티와 되지 않는 프로퍼티가 있다.

```python

INHERITED_PROPERTIES = {
    "font-size": "16px",
    "font-style": "normal",
    "font-weight": "normal",
    "color": "black",
}

def style(node, rules):
    node.style = {}
    for property, default_value in INHERITED_PROPERTIES.items():
        if node.parent:
            node.style[property] = node.parent.style[property]
        else:
            node.style[property] = default_value

    if node.style["font-size"].endswith("%"):
        if node.parent:
            parent_font_size = node.parent.style["font-size"]
        else:
            parent_font_size = INHERITED_PROPERTIES["font-size"]
        node_pct = float(node.style["font-size"][:-1]) / 100
        parent_px = float(parent_font_size[:-2])
        node.style["font-size"] = str(node_pct * parent_px) + "px"

```

- 부모에게 상속받을 텍스트 스타일이 있다면 상속 받고 아닌 경우 설정한 기본 값을 사용
- '%' 사용 시 에는 절대적인 픽셀로 변경 (computed style)

## 6.7 폰트 프로퍼티

```css
a {
  color: blue;
}
i {
  font-style: italic;
}
b {
  font-weight: bold;
}
small {
  font-size: 90%;
}
big {
  font-size: 110%;
}
```

- css 파일로 이동

```python

class BlockLayout:
    def word(self, node, word):
        weight = node.style["font-weight"]
        style = node.style["font-style"]
        if style == "normal": style = "roman"
        size = int(float(node.style["font-size"][:-2]) * .75)
        font = get_font(self.size, self.weight, self.style)

        w = font.measure(word)
        if self.cursor_x + w > self.width:
            self.flush()
        color = node.style["color"]
        self.line.append((self.cursor_x, word, font, color))
        self.cursor_x += w + font.measure(" ")

    def flush(self):
        if not self.line: return
        metrics = [font.metrics() for x, word, font, color in self.line]
        max_ascent = max([metric["ascent"] for metric in metrics])
        baseline = self.cursor_y + 1.25 * max_ascent
        for rel_x, word, font, color in self.line:
            x = self.x + rel_x
            y = self.y + baseline - font.metrics("ascent")
            self.display_list.append((x, y, word, font, color))
        max_descent = max([metric["descent"] for metric in metrics])
        self.cursor_y = baseline + 1.25 * max_descent
        self.cursor_x = 0
        self.line = []

    def paint(self):
        cmds = []
        bgcolor = self.node.style.get("background-color",
                                      "transparent")
        if bgcolor != "transparent":
            x2, y2 = self.x + self.width, self.y + self.height
            rect = DrawRect(self.x, self.y, x2, y2, bgcolor)
            cmds.append(rect)

        if self.layout_mode() == "inline":
            for x, y, word, font, color in self.display_list:
                cmds.append(DrawText(x, y, word, font, color))
        return cmds
```

- color는 line에 저장
- flush에서 display_list에 추가하고 paint에서 커맨드로 변환

```python
class DrawText:
    def __init__(self, x1, y1, text, font, color):
        self.top = y1
        self.left = x1
        self.text = text
        self.font = font
        self.color = color

        self.bottom = y1 + font.metrics("linespace")

    def execute(self, scroll, canvas):
        canvas.create_text(
            self.left, self.top - scroll,
            text=self.text,
            font=self.font,
            anchor='nw',
            fill=self.color)
```

- DrawText에 컬러 인수를 넘겨주고 실행 시 fill로 전달받은 컬러로 렌더링

```python

class BlockLayout:
    def recurse(self, node):
        if isinstance(node, Text):
            for word in node.text.split():
                self.word(node, word)
        else:
            if node.tag == "br":
                self.flush();
            for child in node.children:
                self.recurse(child)

```

- open/close tag 관련 로직 제거
- 스타일시트는 더 간단하고 편집하기 쉬우니 큰 개선
