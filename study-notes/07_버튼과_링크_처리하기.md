# 버튼과 링크 처리하기

## 7.1 링크는 어디에 있는가?

- 웹의 핵심은 링크이므로 브라우저 인터페이스의 가장 중요한 부분은 링크를 클릭하는 것
- 링크 구현을 위해서는 서식이 있는 텍스트가 필요

```html
<html>
  <body>
    Here is some text that is
    <br />
    spread across multiple lines
  </body>
</html>
```

```
DocumentLayout
  BlockLayout[block] (html)
    BlockLayout[block] (body)
      LineLayout[block] (first line)
        TextLayout[block] (Here)
        TextLayout[block] (is)
        ...
      LineLayout[block] (secind line)
        TextLayout[block] (spread)
        ...
```

```python

class LineLayout:
    def __init__(self, node, parent, previous):
        self.node = node
        self.parent = parent
        self.previous = previous
        self.children = []

    def layout(self):
        self.width = self.parent.width
        self.x = self.parent.x

        if self.previous:
            self.y = self.previous.y + self.previous.height
        else:
            self.y = self.parent.y

        for word in self.children:
            word.layout()

        max_ascent = max([word.font.metrics("ascent")
                          for word in self.children])
        baseline = self.y + 1.25 * max_ascent
        for word in self.children:
            word.y = baseline - word.font.metrics("ascent")
        max_descent = max([word.font.metrics("descent")
                           for word in self.children])
        self.height = 1.25 * (max_ascent + max_descent)

    def paint(self):
        return []

class TextLayout:
    def __init__(self, node, word, parent, previous):
        self.node = node
        self.word = word
        self.children = []
        self.parent = parent
        self.previous = previous

    def layout(self):
        weight = self.node.style["font-weight"]
        style = self.node.style["font-style"]
        if style == "normal": style = "roman"
        size = int(float(self.node.style["font-size"][:-2]) * .75)
        self.font = get_font(size, weight, style)

        self.width = self.font.measure(self.word)

        if self.previous:
            space = self.previous.font.measure(" ")
            self.x = self.previous.x + space + self.previous.width
        else:
            self.x = self.parent.x

        self.height = self.font.metrics("linespace")

    def paint(self):
        color = self.node.style["color"]
        return [DrawText(self.x, self.y, self.word, self.font, color)]

class BlockLayout:
    def new_line(self):
        self.cursor_x = 0
        last_line = self.children[-1] if self.children else None
        new_line = LineLayout(self.node, self, last_line)
        self.children.append(new_line)

    def word(self, node, word):
        weight = node.style["font-weight"]
        style = node.style["font-style"]
        if style == "normal": style = "roman"
        size = int(float(node.style["font-size"][:-2]) * .75)
        font = get_font(self.size, self.weight, self.style)

        w = font.measure(word)
        if self.cursor_x + w > self.width:
            self.new_line()
        line = self.children[-1]
        previous_word = line.children[-1] if line.children else None
        text = TextLayout(node, word, line, previous_word)
        line.children.append(text)
        self.cursor_x += w + font.measure(" ")

    def layout(self):
        self.x = self.parent.x
        self.width = self.parent.width

        if self.previous:
            self.y = self.previous.y + self.previous.height
        else:
            self.y = self.parent.y

        mode = self.layout_mode()
        if mode == "block":
            previous = None
            for child in self.node.children:
                next = BlockLayout(child, self, previous)
                self.children.append(next)
                previous = next
        else:
            self.cursor_y = 0
            self.weight = "normal"
            self.style = "roman"
            self.size = 12

            self.new_line()
            self.recurse(self.node)

        for child in self.children:
            child.layout()

        self.height = sum([child.height for child in self.children])
```

- `TextLayout`은 word 추가 인수가 필요
- `LineLayout`와 `TextLayout`의 생성은 단어를 줄바꿈 하는 동안 일어나야 한다.

## 7.2 라인 레이아웃

### 레이아웃 시스템 재설계 배경

#### 기존 시스템의 구조적 문제

```python
# 기존 BlockLayout (inline 모드)
class BlockLayout:
    def __init__(self):
        self.line = []  # 임시 버퍼: [(x, word, font, color), ...]
        self.display_list = []  # 최종 출력

    def word(self, node, word):
        # 단어를 line에 추가 (y 좌표 없음!)
        self.line.append((self.cursor_x, word, font, color))

    def flush(self):
        # 한 줄의 모든 단어를 한번에 처리
        # 1. 베이스라인 계산
        # 2. 각 단어의 y 좌표 계산
        # 3. display_list에 추가
```

**문제점**:

1. **레이아웃 트리 불일치**: Block 자식은 객체(`BlockLayout`), Inline 자식은 튜플 → 순회/검색 불가능
2. **타이밍 문제**: 단어 추가 시점에는 y 좌표를 알 수 없음 (줄의 모든 단어를 봐야 높이 결정)
3. **HTML 노드 추적 불가**: 튜플에는 스타일 정보만 있고 원본 노드 참조 없음 → 링크 클릭 구현 불가
4. **확장 어려움**: 이미지, 버튼 등 새로운 inline 요소 추가 시 `flush()` 전체 수정 필요

---

### 새로운 3계층 구조

```
BlockLayout (inline 모드)
├─ LineLayout (줄 1)
│   ├─ TextLayout (단어 1)
│   └─ TextLayout (단어 2)
└─ LineLayout (줄 2)
    └─ TextLayout (단어 3)
```

---

### LineLayout의 핵심: 베이스라인 정렬

#### 타이포그래피 문제

한 줄에 크기가 다른 폰트가 섞이면 어떻게 정렬할까?

```
Here is [LARGE] text   ← 큰 글자
     ↑
  베이스라인 (모든 글자가 "앉는" 기준선)
```

**베이스라인 정렬 규칙**:

- 모든 글자는 동일한 베이스라인 위에 배치
- 베이스라인은 가장 큰 글자의 `ascent`(기준선 위 높이)로 결정
- 줄 높이는 최대 `ascent` + 최대 `descent`(기준선 아래 높이)

```python
class LineLayout:
    def layout(self):
        # 1. 자식 단어들의 x 좌표만 먼저 계산
        for word in self.children:
            word.layout()  # TextLayout.layout() 호출

        # 2. 모든 단어를 보고 베이스라인 위치 결정
        max_ascent = max([word.font.metrics("ascent")
                          for word in self.children])
        baseline = self.y + 1.25 * max_ascent  # 줄 간격 여유 1.25배

        # 3. 베이스라인 기준으로 각 단어의 y 좌표 조정
        for word in self.children:
            word.y = baseline - word.font.metrics("ascent")

        # 4. 줄 높이 계산
        max_descent = max([word.font.metrics("descent")
                           for word in self.children])
        self.height = 1.25 * (max_ascent + max_descent)
```

**LineLayout이 담당하는 것**:

- ✅ 한 줄의 모든 단어를 자식으로 관리
- ✅ 베이스라인 계산 및 단어 y 좌표 조정
- ✅ 줄 높이 계산 (다음 줄의 y 위치 결정에 사용)

**LineLayout이 하지 않는 것**:

- ❌ 개별 단어의 스타일 처리 → `TextLayout`이 담당
- ❌ 줄바꿈 판단 → `BlockLayout.word()`가 담당

---

### TextLayout의 핵심: 단어 단위 독립성

#### 왜 단어마다 객체가 필요한가?

**1. 스타일 독립성**

```html
Here is <b>bold</b> text
```

→ 각 단어가 다른 `Text` 노드에 속함 → 스타일이 다름

**2. 클릭 이벤트 처리**

```html
Click <a href="...">this link</a> here
```

→ "this"와 "link"를 클릭했을 때 어느 `<a>` 태그인지 알아야 함

**3. 동적 레이아웃**

```
[Here] [is] [some] [text]
  ↓ 창 크기 변경
[Here] [is]
[some] [text]
```

→ 각 단어의 위치를 독립적으로 재계산

```python
class TextLayout:
    def __init__(self, node, word, parent, previous):
        self.node = node  # ⭐ HTML 노드 참조 (스타일 + 클릭 이벤트용)
        self.word = word  # 실제 텍스트
        self.parent = parent  # LineLayout
        self.previous = previous  # 이전 TextLayout

    def layout(self):
        # 1. 노드의 스타일에서 폰트 정보 추출
        weight = self.node.style["font-weight"]
        style = self.node.style["font-style"]
        size = int(float(self.node.style["font-size"][:-2]) * .75)
        self.font = get_font(size, weight, style)

        # 2. 단어 너비 계산
        self.width = self.font.measure(self.word)

        # 3. 이전 단어 오른쪽에 배치 (x 좌표만 계산, y는 나중에)
        if self.previous:
            space = self.previous.font.measure(" ")
            self.x = self.previous.x + space + self.previous.width
        else:
            self.x = self.parent.x  # 줄의 시작

    def paint(self):
        color = self.node.style["color"]
        return [DrawText(self.x, self.y, self.word, self.font, color)]
```

**TextLayout이 담당하는 것**:

- ✅ 자신의 스타일 정보 관리 (폰트, 색상)
- ✅ 자신의 x 좌표 계산 (이전 단어 기준 상대 위치)
- ✅ 자신의 그리기 명령 생성
- ✅ 원본 HTML 노드 참조 유지 (클릭 이벤트용)

**TextLayout이 하지 않는 것**:

- ❌ 베이스라인 정렬 → `LineLayout`이 담당
- ❌ 줄바꿈 판단 → `BlockLayout`이 담당

---

### 분리의 핵심 이유

#### 1. 타이포그래피의 복잡성 분리

**문제**: 한 줄의 높이는 가장 큰 글자에 의해 결정됨

```
Here is [LARGE] and small text
         ^^^^^
    이 단어 때문에 줄 높이가 커짐
```

**해결**:

- `TextLayout`: 자신의 폰트만 신경씀
- `LineLayout`: 모든 자식의 폰트를 보고 베이스라인 결정

#### 2. 2단계 레이아웃

```python
# 1단계: x 좌표 계산 (좌→우 순차 배치)
for word in line.children:
    word.layout()  # 이전 단어 기준으로 x 계산

# 2단계: y 좌표 조정 (베이스라인 정렬)
baseline = calculate_baseline()
for word in line.children:
    word.y = baseline - word.font.ascent
```

**분리 이유**: x와 y는 계산 타이밍이 다름

- x: 단어 추가 시점에 결정 가능
- y: 줄의 모든 단어를 봐야 결정 가능

#### 3. 확장 가능한 설계

새로운 inline 요소 추가 예시:

```python
class ImageLayout:  # TextLayout과 동일한 인터페이스
    def layout(self):
        self.width = image.width
        if self.previous:
            self.x = self.previous.x + self.previous.width
        else:
            self.x = self.parent.x

    def paint(self):
        return [DrawImage(self.x, self.y, self.image)]

# BlockLayout.word()만 수정
def add_inline_element(self, node):
    if isinstance(node, Text):
        return TextLayout(...)
    elif node.tag == "img":
        return ImageLayout(...)
```

**분리 효과**: `LineLayout`이나 베이스라인 계산 로직은 수정 불필요

---

### BlockLayout의 역할 변화

```python
class BlockLayout:
    def word(self, node, word):
        # 1. 현재 줄 가져오기
        line = self.children[-1]

        # 2. 줄바꿈 필요하면 새 LineLayout 생성
        font = get_font(...)
        if self.cursor_x + font.measure(word) > self.width:
            self.new_line()
            line = self.children[-1]

        # 3. TextLayout 생성 및 추가
        previous = line.children[-1] if line.children else None
        text = TextLayout(node, word, line, previous)
        line.children.append(text)
```

**BlockLayout의 책임**:

- ✅ inline/block 모드 판단
- ✅ 줄바꿈 시점 결정
- ✅ `LineLayout` 생성 관리

**위임된 책임**:

- 베이스라인 정렬 → `LineLayout`
- 단어 스타일 처리 → `TextLayout`

---

### 분리의 최종 효과

| 이전                       | 이후                           |
| -------------------------- | ------------------------------ |
| BlockLayout이 모든 것 처리 | 3개 클래스가 책임 분담         |
| 튜플로 데이터 저장         | 객체로 구조화                  |
| HTML 노드 추적 불가        | `TextLayout.node`로 추적       |
| 새 요소 추가 시 전체 수정  | 새 클래스만 추가               |
| 클릭 처리 불가             | 레이아웃 트리 순회로 클릭 처리 |

**결과**: 링크 클릭, 호버 효과, 이미지 배치 등 구현 가능해짐

## 7.3 클릭 처리

### 클릭 처리 시스템 구조

#### 기존 시스템: 클릭 처리 불가능

```python
# 기존: 튜플 기반 display_list
display_list = [(x, y, word, font, color), ...]
# 문제:
# 1. 어떤 단어가 클릭되었는지 알 수 없음 (좌표 정보만 있음)
# 2. 클릭된 단어가 어떤 HTML 노드인지 추적 불가
# 3. <a> 태그 찾기 불가능
```

#### 새로운 시스템: 3단계 클릭 처리

```
마우스 클릭
    ↓
Browser.handle_click() ← tkinter 이벤트
    ↓
Chrome 영역?  YES → Chrome.click() → UI 요소 처리
    ↓ NO
Tab.click() → 레이아웃 트리 순회 → 링크 처리
```

---

### 1단계: Rect 클래스 - 클릭 가능 영역

#### Rect의 역할

모든 화면 요소의 **클릭 가능 영역**을 표현하고 **점 포함 여부**를 판단

```python
class Rect:
    def __init__(self, left, top, right, bottom):
        self.left = left    # x 시작
        self.top = top      # y 시작
        self.right = right  # x 끝
        self.bottom = bottom  # y 끝

    def contains_point(self, x, y):
        """(x, y) 좌표가 이 사각형 안에 있는지 판단"""
        return x >= self.left and x < self.right \
            and y >= self.top and y < self.bottom
```

#### Drawing 클래스들의 rect 속성

모든 그리기 명령이 자신의 영역을 `Rect`로 관리

```python
class DrawText:
    def __init__(self, x1, y1, text, font, color):
        # ⭐ 텍스트의 클릭 가능 영역 계산
        self.rect = Rect(x1, y1,
            x1 + font.measure(text),  # 너비
            y1 + font.metrics("linespace"))  # 높이
        self.text = text
        self.font = font
        self.color = color

class DrawRect:
    def __init__(self, rect, color):
        self.rect = rect  # 배경의 영역
        self.color = color

class DrawLine:
    def __init__(self, x1, y1, x2, y2, color, thickness):
        self.rect = Rect(x1, y1, x2, y2)  # 선의 영역
        # ...
```

**핵심**: 화면의 모든 요소가 `rect` 속성을 통해 자신의 위치와 크기를 알고 있음

---

### 2단계: Browser.handle_click() - 최상위 이벤트 핸들러

```python
class Browser:
    def __init__(self):
        # tkinter 이벤트 바인딩
        self.window.bind("<Button-1>", self.handle_click)

    def handle_click(self, e):
        """마우스 클릭 이벤트를 Chrome 또는 Tab으로 위임"""
        if e.y < self.chrome.bottom:
            # Chrome UI 영역 클릭 (탭바, 주소창 등)
            self.chrome.click(e.x, e.y)
        else:
            # Tab 콘텐츠 영역 클릭 (링크 등)
            tab_y = e.y - self.chrome.bottom  # Chrome 높이만큼 빼기
            self.active_tab.click(e.x, tab_y)

        self.draw()  # 화면 다시 그리기
```

**역할**:

- tkinter에서 마우스 클릭 이벤트 수신
- Y 좌표로 Chrome 영역과 Tab 영역 구분
- 해당 영역의 `click()` 메서드로 위임

---

### 3단계: Chrome.click() - UI 요소 클릭

```python
class Chrome:
    def __init__(self, browser):
        # UI 요소들의 영역을 Rect로 정의
        self.newtab_rect = Rect(...)    # "+" 버튼
        self.back_rect = Rect(...)      # "<" 뒤로가기
        self.address_rect = Rect(...)   # 주소창

    def tab_rect(self, i):
        """i번째 탭의 영역 계산"""
        return Rect(...)

    def click(self, x, y):
        """UI 요소 클릭 처리"""
        self.focus = None  # 포커스 초기화

        # 각 UI 요소의 rect로 클릭 영역 판단
        if self.newtab_rect.contains_point(x, y):
            # 새 탭 열기
            self.browser.new_tab(URL("https://browser.engineering/"))

        elif self.back_rect.contains_point(x, y):
            # 뒤로가기
            self.browser.active_tab.go_back()

        elif self.address_rect.contains_point(x, y):
            # 주소창 포커스
            self.focus = "address bar"
            self.address_bar = ""

        else:
            # 탭 클릭 판단
            for i, tab in enumerate(self.browser.tabs):
                if self.tab_rect(i).contains_point(x, y):
                    self.browser.active_tab = tab
                    break
```

**핵심**:

- `Rect.contains_point()`로 어떤 UI 요소가 클릭되었는지 판단
- if-elif 체인으로 UI 요소별 동작 실행

---

### 4단계: Tab.click() - 링크 클릭 처리 ⭐ 핵심

#### 링크 클릭의 문제

```html
<p>Click <a href="/page">this link</a> here</p>
```

**문제**:

1. 사용자가 "this" 단어를 클릭함
2. 어떤 `TextLayout`이 클릭되었는지 찾아야 함
3. 그 `TextLayout`의 `node`가 어떤 `<a>` 태그 안에 있는지 찾아야 함

#### 해결: 레이아웃 트리 순회 + HTML 트리 역추적

```python
class Tab:
    def click(self, x, y):
        # 1. 스크롤 보정
        y += self.scroll  # 화면 좌표 → 문서 좌표

        # 2. 레이아웃 트리 순회: 클릭된 모든 레이아웃 객체 찾기
        objs = [obj for obj in tree_to_list(self.document, [])
            if obj.x <= x < obj.x + obj.width
            and obj.y <= y < obj.y + obj.height]

        if not objs:
            return  # 빈 공간 클릭

        # 3. 가장 안쪽 레이아웃 객체 선택 (겹쳐진 경우 마지막)
        elt = objs[-1].node  # ⭐ TextLayout.node로 HTML 노드 접근

        # 4. HTML 트리 역추적: <a> 태그 찾기
        while elt:
            if isinstance(elt, Text):
                pass  # Text 노드는 건너뛰기
            elif elt.tag == "a" and "href" in elt.attributes:
                # <a> 태그 발견!
                url = self.url.resolve(elt.attributes["href"])
                return self.load(url)

            elt = elt.parent  # 부모 노드로 이동

        # <a> 태그를 찾지 못하면 아무것도 하지 않음
```

#### 단계별 분석

**1단계: 스크롤 보정**

```python
y += self.scroll
```

- 화면 좌표 (0~600) → 문서 좌표 (0~∞)
- 스크롤된 만큼 y 좌표 보정

**2단계: 레이아웃 트리 순회**

```python
objs = [obj for obj in tree_to_list(self.document, [])
    if obj.x <= x < obj.x + obj.width
    and obj.y <= y < obj.y + obj.height]
```

- `tree_to_list()`: 레이아웃 트리를 평면 리스트로 변환
- 각 레이아웃 객체의 x, y, width, height로 클릭 영역 판단
- **결과**: 클릭된 모든 레이아웃 객체 목록 (부모~자식 순)

**왜 여러 객체가 리턴될까?**

```
BlockLayout (p 태그)  ← 클릭 영역에 포함
  ├─ LineLayout       ← 클릭 영역에 포함
  │   └─ TextLayout ("this")  ← 실제 클릭된 객체
```

**3단계: 가장 안쪽 객체 선택**

```python
elt = objs[-1].node
```

- `objs[-1]`: 가장 마지막 = 가장 안쪽 레이아웃 (TextLayout)
- `.node`: `TextLayout`의 HTML 노드 (`Text` 노드)

**4단계: HTML 트리 역추적**

```python
while elt:
    if isinstance(elt, Text):
        pass
    elif elt.tag == "a" and "href" in elt.attributes:
        url = self.url.resolve(elt.attributes["href"])
        return self.load(url)
    elt = elt.parent
```

HTML 구조:

```
<p>                     ← elt.parent.parent
  <a href="/page">      ← elt.parent (찾음!)
    "this"              ← elt (시작점)
```

- `Text` 노드 → 부모 `<a>` 태그 → `href` 속성 확인
- `href` 발견 시 URL 해석 후 페이지 로드

---

### 클릭 처리 플로우 요약

```
사용자가 "this link" 클릭
    ↓
Browser.handle_click(e.x=150, e.y=300)
    ↓
e.y (300) >= chrome.bottom (60)?
YES ↓
Tab.click(x=150, y=240)  # 240 = 300 - 60
    ↓
y += scroll (y = 240 + 100 = 340)
    ↓
레이아웃 트리 순회:
  - BlockLayout (p) at (10, 300, 790, 350) ✓
  - LineLayout at (10, 300, 790, 330) ✓
  - TextLayout ("this") at (150, 310, 190, 325) ✓
    ↓
objs[-1] = TextLayout ("this")
    ↓
elt = TextLayout.node = Text("this")
    ↓
HTML 트리 역추적:
  - Text("this") → 부모로
  - Element(a, href="/page") → 찾았다!
    ↓
url = URL("http://example.com/page")
    ↓
self.load(url)
```

---

### 레이아웃 시스템 재설계의 효과

| 항목             | 기존 (튜플)                | 개선 (객체)                          |
| ---------------- | -------------------------- | ------------------------------------ |
| **클릭 영역**    | display_list에 x, y만 있음 | 모든 레이아웃 객체가 x, y, w, h      |
| **HTML 추적**    | 불가능 (튜플에 node 없음)  | `TextLayout.node`로 즉시 접근        |
| **겹침 판단**    | 불가능                     | 부모~자식 모두 찾아 마지막 선택      |
| **링크 찾기**    | 불가능                     | HTML 트리 역추적으로 `<a>` 태그 찾기 |
| **UI 클릭 처리** | 구현 불가                  | `Rect.contains_point()` 활용         |

**핵심**: 객체 기반 레이아웃 → 클릭된 요소의 HTML 노드 추적 → 링크 처리 가능

## 7.4 탭 브라우징

### 기존 시스템: 단일 페이지 브라우저

```python

class Browser:
    def __init__(self):
        self.window = tkinter.Tk()
        self.canvas = tkinter.Canvas(...)
        self.scroll = 0          # 스크롤 위치
        self.display_list = []   # 그리기 명령

    def load(self, url):
        """페이지 로드: HTML 파싱 → 레이아웃 → 렌더링"""
        body = url.request()
        self.nodes = HTMLParser(body).parse()
        # ...
        self.draw()

    def draw(self):
        """화면에 그리기"""
        self.canvas.delete("all")
        for cmd in self.display_list:
            cmd.execute(self.scroll, self.canvas)

    def scrolldown(self, e):
        """스크롤 처리"""
        self.scroll += SCROLL_STEP
        self.draw()
```

**문제점**:

- ❌ 한 번에 하나의 페이지만 표시 가능
- ❌ 여러 페이지를 동시에 열 수 없음
- ❌ 브라우저 UI (탭바, 주소창)가 없음
- ❌ 탭 전환 불가능

---

### 새로운 시스템: 멀티탭 브라우저

#### 3계층 아키텍처

```
Browser (최상위 컨트롤러)
├─ Chrome (브라우저 UI)
│   ├─ 탭바 (Tab 0, Tab 1, Tab 2, +)
│   ├─ 주소창
│   └─ 뒤로가기 버튼
└─ tabs[] (여러 Tab 객체)
    ├─ Tab 0 (https://example.com)
    ├─ Tab 1 (https://google.com)
    └─ Tab 2 (https://github.com)
```

---

### Tab 클래스 - 개별 탭 관리

기존 `Browser`의 페이지 관련 기능을 분리

```python
class Tab:
    def __init__(self, tab_height):
        self.scroll = 0           # 이 탭의 스크롤 위치
        self.display_list = []    # 이 탭의 그리기 명령
        self.url = None           # 이 탭의 현재 URL
        self.history = []         # 이 탭의 방문 기록
        self.tab_height = tab_height  # 탭 영역 높이

    def load(self, url):
        """페이지 로드 (기존 Browser.load()와 동일)"""
        self.url = url
        self.history.append(url)  # 히스토리에 추가
        body = url.request()
        self.nodes = HTMLParser(body).parse()
        # CSS 적용, 레이아웃, 페인팅
        # ...

    def click(self, x, y):
        """링크 클릭 처리"""
        y += self.scroll
        # 레이아웃 트리 순회 → <a> 태그 찾기
        # ...

    def draw(self, canvas, offset):
        """이 탭의 콘텐츠를 canvas에 그리기"""
        for cmd in self.display_list:
            # Chrome 영역(offset) 아래에 그리기
            if cmd.rect.top > self.scroll + self.tab_height:
                continue
            if cmd.rect.bottom < self.scroll:
                continue
            cmd.execute(self.scroll - offset, canvas)

    def scrolldown(self):
        """이 탭의 스크롤 다운"""
        max_y = max(
            self.document.height + 2*VSTEP - self.tab_height, 0)
        self.scroll = min(self.scroll + SCROLL_STEP, max_y)
```

**Tab의 책임**:

- ✅ 개별 탭의 웹페이지 콘텐츠 관리
- ✅ 독립적인 스크롤 위치
- ✅ 독립적인 방문 기록
- ✅ 페이지 로드, 렌더링, 클릭 처리

---

### Browser 클래스 - 탭 관리

```python
class Browser:
    def __init__(self):
        self.window = tkinter.Tk()
        self.canvas = tkinter.Canvas(...)

        # 이벤트 바인딩
        self.window.bind("<Down>", self.handle_down)
        self.window.bind("<Button-1>", self.handle_click)

        # 멀티탭 관리
        self.tabs = []           # Tab 객체 리스트
        self.active_tab = None   # 현재 활성 탭
        self.chrome = Chrome(self)  # 브라우저 UI

    def handle_click(self, e):
        """클릭 이벤트 위임"""
        if e.y < self.chrome.bottom:
            # Chrome 영역 클릭 (7.5에서 상세 설명)
            self.chrome.click(e.x, e.y)
        else:
            # Tab 영역 클릭
            tab_y = e.y - self.chrome.bottom
            self.active_tab.click(e.x, tab_y)
        self.draw()

    def new_tab(self, url):
        """새 탭 생성"""
        new_tab = Tab(HEIGHT - self.chrome.bottom)
        new_tab.load(url)
        self.active_tab = new_tab
        self.tabs.append(new_tab)
        self.draw()

    def draw(self):
        """전체 화면 그리기"""
        self.canvas.delete("all")

        # 1. 활성 탭의 콘텐츠 그리기
        self.active_tab.draw(self.canvas, self.chrome.bottom)

        # 2. Chrome UI 그리기 (위에 덮어씀)
        for cmd in self.chrome.paint():
            cmd.execute(0, self.canvas)
```

**Browser의 책임**:

- ✅ 전체 브라우저 창 관리
- ✅ 여러 Tab 객체 관리 (`tabs[]`)
- ✅ 활성 탭 추적 (`active_tab`)
- ✅ Chrome UI 관리
- ✅ 이벤트 수신 및 위임 (Chrome/Tab으로)
- ✅ 전체 화면 렌더링 조율

---

### 탭 생성 및 전환 플로우

#### 새 탭 열기

```
사용자가 "+" 버튼 클릭
    ↓
Browser.handle_click(e.x, e.y)
    ↓
Chrome.click(e.x, e.y)
    ↓
Browser.new_tab(URL("https://browser.engineering/"))
    ↓
new_tab = Tab(HEIGHT - chrome.bottom)
new_tab.load(url)  # 페이지 로드
browser.tabs.append(new_tab)  # 탭 목록에 추가
browser.active_tab = new_tab  # 활성 탭으로 설정
    ↓
Browser.draw()  # 화면 갱신
```

**핵심**:

- `tabs[]`에 새 Tab 객체 추가
- `active_tab` 포인터를 새 탭으로 변경
- 각 탭은 독립적인 상태 유지

#### 탭 전환

```
사용자가 "Tab 1" 클릭
    ↓
Browser.handle_click(e.x, e.y)
    ↓
Chrome.click(e.x, e.y)
    ↓
for i, tab in enumerate(browser.tabs):
    if tab_rect(i).contains_point(x, y):
        browser.active_tab = tab  # 탭 전환!
        break
    ↓
Browser.draw()  # 새로운 활성 탭 렌더링
```

**핵심**:

- `active_tab` 포인터만 변경
- 기존 탭의 상태는 그대로 유지
- 빠른 전환 (O(1))

---

### 시스템 비교

| 항목            | 기존 (단일 페이지)     | 개선 (멀티탭)                          |
| --------------- | ---------------------- | -------------------------------------- |
| **구조**        | Browser 클래스 하나    | Browser + Tab + Chrome                 |
| **탭 관리**     | 불가능                 | 여러 탭 동시 관리, 전환 가능           |
| **UI**          | 없음                   | 탭바, 주소창, 버튼                     |
| **스크롤**      | 전역 스크롤 하나       | 각 탭이 독립적인 스크롤                |
| **히스토리**    | 없음                   | 각 탭이 독립적인 방문 기록             |
| **이벤트 처리** | Browser가 직접 처리    | Browser → Chrome/Tab으로 위임          |
| **렌더링**      | 단일 display_list      | Tab별 display_list + Chrome UI         |
| **책임 분리**   | Browser가 모든 것 담당 | Browser(조율), Tab(콘텐츠), Chrome(UI) |

---

### 핵심 개선점

**1. 관심사 분리 (Separation of Concerns)**

```
Browser:  "어떤 탭이 활성화되어 있고, 어디로 이벤트를 보낼까?"
Tab:      "내 페이지 콘텐츠를 어떻게 렌더링할까?"
Chrome:   "UI 요소를 어떻게 그리고 클릭을 어떻게 처리할까?"
```

**2. 독립성**

- 각 Tab은 독립적인 상태 (스크롤, 히스토리, URL)
- 한 탭에서 스크롤해도 다른 탭에 영향 없음
- 탭 전환 = `active_tab` 포인터만 변경

**3. 확장성**

- 새 탭 추가: `tabs.append(new_tab)`
- 탭 삭제: `tabs.remove(tab)` (구현 가능)
- 탭 순서 변경: 리스트 재정렬 (구현 가능)

**4. 사용자 경험**

- ✅ 멀티태스킹: 여러 페이지 동시 열람
- ✅ 탭 전환: 빠른 탭 전환
- ✅ 주소창: URL 직접 입력
- ✅ 뒤로가기: 방문 기록 관리

**결과**: 단순한 HTML 뷰어 → 실제 사용 가능한 웹 브라우저

## 7.5 브라우저 크롬

### Chrome 클래스 - 브라우저 UI 관리

브라우저의 상단 UI (탭바, 주소창, 버튼)를 담당하는 클래스

```python
class Chrome:
    def __init__(self, browser):
        self.browser = browser
        self.focus = None         # 포커스된 UI 요소
        self.address_bar = ""     # 주소창 입력 텍스트 (7.7)

        self.font = get_font(20, "normal", "roman")
        self.padding = 5

        # UI 요소들의 영역 정의
        self.newtab_rect = Rect(...)    # "+" 버튼
        self.back_rect = Rect(...)      # "<" 뒤로가기 (7.6)
        self.address_rect = Rect(...)   # 주소창 (7.7)

        self.bottom = self.urlbar_bottom  # Chrome 영역의 하단
```

---

### UI 레이아웃 계산

#### tab_rect() - 동적 탭 영역 계산

```python
def tab_rect(self, i):
    """i번째 탭의 영역 계산"""
    tabs_start = self.newtab_rect.right + self.padding
    tab_width = self.font.measure("Tab X") + 2*self.padding
    return Rect(
        tabs_start + tab_width * i, self.tabbar_top,
        tabs_start + tab_width * (i + 1), self.tabbar_bottom)
```

**특징**:

- 동적으로 탭 위치 계산
- "+" 버튼 오른쪽부터 탭 배치
- 탭 개수에 따라 자동 배치

---

### UI 렌더링 - paint()

```python
def paint(self):
    """Chrome UI 그리기"""
    cmds = []

    # 1. 배경 및 구분선
    cmds.append(DrawRect(
        Rect(0, 0, WIDTH, self.bottom), "white"))
    cmds.append(DrawLine(
        0, self.bottom, WIDTH, self.bottom, "black", 1))

    # 2. "+" 버튼
    cmds.append(DrawOutline(self.newtab_rect, "black", 1))
    cmds.append(DrawText(
        self.newtab_rect.left + self.padding,
        self.newtab_rect.top, "+", self.font, "black"))

    # 3. 각 탭 그리기
    for i, tab in enumerate(self.browser.tabs):
        bounds = self.tab_rect(i)

        # 탭 테두리
        cmds.append(DrawLine(
            bounds.left, 0, bounds.left, bounds.bottom,
            "black", 1))
        cmds.append(DrawLine(
            bounds.right, 0, bounds.right, bounds.bottom,
            "black", 1))

        # 탭 제목
        cmds.append(DrawText(
            bounds.left + self.padding, bounds.top + self.padding,
            "Tab {}".format(i), self.font, "black"))

        # 4. 활성 탭 표시
        if tab == self.browser.active_tab:
            # 하단 선 제거로 콘텐츠와 "연결된" 느낌
            cmds.append(DrawLine(
                0, bounds.bottom, bounds.left, bounds.bottom,
                "black", 1))
            cmds.append(DrawLine(
                bounds.right, bounds.bottom, WIDTH, bounds.bottom,
                "black", 1))

    # 5. 뒤로가기 버튼 (7.6에서 사용)
    cmds.append(DrawOutline(self.back_rect, "black", 1))
    cmds.append(DrawText(
        self.back_rect.left + self.padding,
        self.back_rect.top, "<", self.font, "black"))

    # 6. 주소창 (7.7에서 상세 설명)
    cmds.append(DrawOutline(self.address_rect, "black", 1))
    if self.focus == "address bar":
        # 주소 입력 모드
        cmds.append(DrawText(
            self.address_rect.left + self.padding,
            self.address_rect.top,
            self.address_bar, self.font, "black"))
        # 커서 표시
        w = self.font.measure(self.address_bar)
        cmds.append(DrawLine(
            self.address_rect.left + self.padding + w,
            self.address_rect.top,
            self.address_rect.left + self.padding + w,
            self.address_rect.bottom,
            "red", 1))
    else:
        # 현재 URL 표시
        url = str(self.browser.active_tab.url)
        cmds.append(DrawText(
            self.address_rect.left + self.padding,
            self.address_rect.top,
            url, self.font, "black"))

    return cmds
```

**렌더링 순서**:

1. 배경 (흰색) + 구분선
2. "+" 버튼 (새 탭)
3. 탭 목록 (테두리 + 제목 + 활성 탭 표시)
4. 뒤로가기 버튼
5. 주소창 (URL 또는 입력 중 텍스트)

---

### UI 클릭 처리 - click()

```python
def click(self, x, y):
    """Chrome UI 클릭 처리"""
    self.focus = None  # 포커스 초기화

    if self.newtab_rect.contains_point(x, y):
        # 새 탭 열기
        self.browser.new_tab(URL("https://browser.engineering/"))

    elif self.back_rect.contains_point(x, y):
        # 뒤로가기 (7.6에서 상세 설명)
        self.browser.active_tab.go_back()

    elif self.address_rect.contains_point(x, y):
        # 주소창 포커스 (7.7에서 상세 설명)
        self.focus = "address bar"
        self.address_bar = ""

    else:
        # 탭 클릭 → 탭 전환
        for i, tab in enumerate(self.browser.tabs):
            if self.tab_rect(i).contains_point(x, y):
                self.browser.active_tab = tab
                break
```

**클릭 영역 판단 우선순위**:

1. "+" 버튼 → 새 탭
2. "<" 버튼 → 뒤로가기
3. 주소창 → 입력 모드
4. 탭 → 탭 전환
5. 그 외 → 무시

---

### Chrome의 책임

| 항목             | 설명                              |
| ---------------- | --------------------------------- |
| **UI 레이아웃**  | 탭바, 주소창, 버튼의 위치 계산    |
| **UI 렌더링**    | Chrome 영역의 모든 UI 요소 그리기 |
| **클릭 처리**    | UI 요소별 클릭 이벤트 라우팅      |
| **포커스 관리**  | 주소창 입력 모드 상태 관리        |
| **활성 탭 표시** | 현재 활성화된 탭 시각적 구분      |
| **키보드 입력**  | 주소창 입력 처리 (7.7)            |

**핵심**: 브라우저 UI의 모든 것을 담당하는 독립적인 컴포넌트

## 7.6 히스토리 탐색

### Tab.history - 방문 기록 관리

각 탭은 독립적인 방문 기록을 배열로 관리

```python
class Tab:
    def __init__(self, tab_height):
        self.history = []  # 방문한 URL 목록
        # ...

    def load(self, url):
        """페이지 로드 시 히스토리에 추가"""
        self.url = url
        self.history.append(url)  # ⭐ 현재 페이지 추가
        # HTML 파싱, 레이아웃, 렌더링...
```

**히스토리 배열 구조**:

```python
# 예시
history = [
    URL("https://example.com"),      # 0: 첫 페이지
    URL("https://example.com/page1"),  # 1
    URL("https://example.com/page2"),  # 2: 현재 페이지
]
```

---

### go_back() - 뒤로가기 구현

```python
def go_back(self):
    """뒤로가기"""
    if len(self.history) > 1:
        # 1. 현재 페이지 제거
        self.history.pop()

        # 2. 이전 페이지 가져오기
        back = self.history.pop()

        # 3. 이전 페이지 로드 (load()에서 다시 history에 추가됨)
        self.load(back)
```

#### 히스토리 변화 과정

```python
# 초기 상태
history = ["page1.com", "page2.com", "page3.com"]
current = "page3.com"

# go_back() 호출
# 1단계: history.pop()
history = ["page1.com", "page2.com"]  # page3 제거
removed = "page3.com"

# 2단계: back = history.pop()
history = ["page1.com"]
back = "page2.com"

# 3단계: self.load(back)
# load()에서 history.append(url) 호출
history = ["page1.com", "page2.com"]
current = "page2.com"
```

#### 왜 두 번 pop()하는가?

**문제**: `load()`가 호출되면 자동으로 `history.append(url)` 실행

```python
# 잘못된 방법: 한 번만 pop
def go_back_wrong(self):
    back = self.history[-2]  # 이전 페이지
    self.load(back)
    # history = ["page1", "page2", "page3", "page2"]  # 중복!

# 올바른 방법: 두 번 pop
def go_back(self):
    self.history.pop()  # 현재 제거
    back = self.history.pop()  # 이전 가져오기
    self.load(back)  # load()에서 다시 추가
    # history = ["page1", "page2"]  # 정상!
```

---

### 뒤로가기 플로우

```
사용자가 "<" 버튼 클릭
    ↓
Browser.handle_click(e.x, e.y)
    ↓
e.y < chrome.bottom? YES
    ↓
Chrome.click(e.x, e.y)
    ↓
back_rect.contains_point(x, y)? YES
    ↓
browser.active_tab.go_back()
    ↓
Tab.go_back():
    if len(history) > 1:
        history.pop()  # 현재 페이지 제거
        back = history.pop()  # 이전 페이지
        self.load(back)  # 페이지 로드 (history에 재추가)
    ↓
Browser.draw()  # 화면 갱신
```

---

### 히스토리 관리의 특징

**1. 탭별 독립성**

```python
# Tab 0
tab0.history = ["google.com", "github.com"]

# Tab 1
tab1.history = ["stackoverflow.com"]

# 서로 영향 없음
```

**2. 히스토리 순회 제한**

```python
# 현재 구현
- ✅ 뒤로가기 (go_back)
- ❌ 앞으로가기 (미구현)

# 앞으로가기 구현 시 필요한 것
- forward_history = []  # 뒤로간 페이지 저장
- go_forward() 메서드
```

**3. 히스토리 크기 제한 없음**

```python
# 문제: 메모리 누수 가능
history = [page1, page2, ..., page1000]  # 계속 증가

# 개선 방안
MAX_HISTORY = 50
if len(self.history) > MAX_HISTORY:
    self.history = self.history[-MAX_HISTORY:]
```

**핵심**: 간단한 스택 기반 히스토리 관리

## 7.7 URL 입력하기

### 주소창 포커스 및 입력 상태

```python
class Chrome:
    def __init__(self, browser):
        self.focus = None         # 포커스된 UI 요소
        self.address_bar = ""     # 입력 중인 텍스트
```

**포커스 상태**:

- `None`: 일반 모드 (현재 URL 표시)
- `"address bar"`: 입력 모드 (텍스트 입력 + 커서 표시)

---

### 주소 입력 플로우

#### 1. 주소창 클릭 (포커스)

```python
# Chrome.click()
elif self.address_rect.contains_point(x, y):
    self.focus = "address bar"  # 입력 모드 활성화
    self.address_bar = ""       # 입력 필드 초기화
```

```
사용자가 주소창 클릭
    ↓
Chrome.click(x, y)
    ↓
self.focus = "address bar"
self.address_bar = ""
    ↓
Browser.draw()  # 입력 모드로 UI 갱신
```

#### 2. 텍스트 입력

```python
# Browser.handle_key()
def handle_key(self, e):
    """키 입력 → Chrome으로 위임"""
    if len(e.char) == 0: return  # 특수키 무시
    if not (0x20 <= ord(e.char) < 0x7f): return  # ASCII 범위만
    self.chrome.keypress(e.char)
    self.draw()

# Chrome.keypress()
def keypress(self, char):
    """키보드 입력 처리"""
    if self.focus == "address bar":
        self.address_bar += char  # 입력 텍스트에 추가
```

```
사용자가 "g" 입력
    ↓
Browser.handle_key(e)
    ↓
Chrome.keypress("g")
    ↓
if focus == "address bar":
    address_bar += "g"  # address_bar = "g"
    ↓
Browser.draw()  # "g" 표시

사용자가 "o", "o", "g", "l", "e" 연속 입력
    ↓
(반복...)
    ↓
address_bar = "google"  # 최종 결과
```

#### 3. Enter 키 (페이지 이동)

```python
# Browser.handle_enter()
def handle_enter(self, e):
    """Enter 키 → Chrome으로 위임"""
    self.chrome.enter()
    self.draw()

# Chrome.enter()
def enter(self):
    """Enter 키 처리"""
    if self.focus == "address bar":
        # 입력된 주소로 페이지 로드
        self.browser.active_tab.load(URL(self.address_bar))
        self.focus = None  # 입력 모드 종료
```

```
사용자가 Enter 키 입력
    ↓
Browser.handle_enter(e)
    ↓
Chrome.enter()
    ↓
if focus == "address bar":
    browser.active_tab.load(URL(address_bar))
    self.focus = None
    ↓
Tab.load(URL("google"))
    ↓
Browser.draw()  # 새 페이지 표시
```

---

### 주소창 UI 변화

#### 일반 모드 (`focus = None`)

```python
# Chrome.paint()
if self.focus == "address bar":
    # ...
else:
    # 현재 URL 표시
    url = str(self.browser.active_tab.url)
    cmds.append(DrawText(
        self.address_rect.left + self.padding,
        self.address_rect.top,
        url, self.font, "black"))
```

```
┌────────────────────────────┐
│ https://example.com/page   │  ← 현재 URL
└────────────────────────────┘
```

#### 입력 모드 (`focus = "address bar"`)

```python
# Chrome.paint()
if self.focus == "address bar":
    # 입력 중인 텍스트 표시
    cmds.append(DrawText(
        self.address_rect.left + self.padding,
        self.address_rect.top,
        self.address_bar, self.font, "black"))

    # 커서 표시 (빨간 세로선)
    w = self.font.measure(self.address_bar)
    cmds.append(DrawLine(
        self.address_rect.left + self.padding + w,
        self.address_rect.top,
        self.address_rect.left + self.padding + w,
        self.address_rect.bottom,
        "red", 1))
```

```
┌────────────────────────────┐
│ google|                    │  ← 입력 텍스트 + 커서
└────────────────────────────┘
```

---

### 키 입력 필터링

```python
def handle_key(self, e):
    if len(e.char) == 0: return  # 특수키 (Shift, Ctrl 등) 무시
    if not (0x20 <= ord(e.char) < 0x7f): return  # ASCII 인쇄 가능 문자만
    self.chrome.keypress(e.char)
```

**필터링 이유**:

- `0x20` (스페이스) ~ `0x7f` (DEL 직전): 인쇄 가능한 ASCII 문자
- 특수키 (화살표, Ctrl+C 등)는 무시
- 한글 등 유니코드는 미지원 (간단한 구현)

---

### 전체 플로우 요약

```
1. 주소창 클릭
   → focus = "address bar"
   → address_bar = ""
   → UI: 빈 입력창 + 커서

2. "google" 입력 (6번의 키 입력)
   → keypress("g") → address_bar = "g"
   → keypress("o") → address_bar = "go"
   → keypress("o") → address_bar = "goo"
   → keypress("g") → address_bar = "goog"
   → keypress("l") → address_bar = "googl"
   → keypress("e") → address_bar = "google"
   → UI: "google" + 커서

3. Enter 키
   → active_tab.load(URL("google"))
   → focus = None
   → UI: 페이지 로딩 → 새 페이지 표시
```

**핵심**: 포커스 상태 기반 입력 모드 전환
