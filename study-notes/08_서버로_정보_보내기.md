# 서버로 정보 보내기

브라우저에 **폼(Form) 기능**을 추가하여 사용자가 서버로 데이터를 POST 요청으로 전송할 수 있게 기능 추가 및 입력 필드, 버튼, 포커스 관리 등 상호작용 시스템 구현

---

## 주요 변경사항

### 1. urllib.parse 모듈 추가

```diff
  import socket
  import ssl
  import tkinter
  import tkinter.font
+ import urllib.parse
```

**목적**: 폼 데이터의 URL 인코딩 (특수문자, 공백 등을 안전하게 변환)

---

### 2. POST 요청 지원

```diff
- def request(self):
+ def request(self, payload=None):
      s = socket.socket(
          family=socket.AF_INET,
          type=socket.SOCK_STREAM,
          proto=socket.IPPROTO_TCP,
      )
      s.connect((self.host, self.port))

      if self.scheme == "https":
          ctx = ssl.create_default_context()
          s = ctx.wrap_socket(s, server_hostname=self.host)

-     request = "GET {} HTTP/1.0\r\n".format(self.path)
+     method = "POST" if payload else "GET"  # payload 유무로 메서드 결정
+     request = "{} {} HTTP/1.0\r\n".format(method, self.path)
+     if payload:
+         length = len(payload.encode("utf8"))
+         request += "Content-Length: {}\r\n".format(length)  # POST 필수 헤더
      request += "Host: {}\r\n".format(self.host)
      request += "\r\n"
+     if payload:
+         request += payload  # 요청 본문에 데이터 추가
      s.send(request.encode("utf8"))
```

**핵심 개선**:

- `payload` 매개변수로 GET/POST 자동 전환
- POST 요청 시 `Content-Length` 헤더 자동 계산
- HTTP 프로토콜 명세 준수 (헤더-본문 분리)

---

### 3. 포커스 상태 추가

```diff
  class Text:
      def __init__(self, text, parent):
          self.text = text
          self.children = []
          self.parent = parent
+         self.is_focused = False  # 포커스 추적

  class Element:
      def __init__(self, tag, attributes, parent):
          self.tag = tag
          self.attributes = attributes
          self.children = []
          self.parent = parent
+         self.is_focused = False  # 포커스 추적
```

**활용**: 어떤 입력 필드가 활성화되어 있는지 추적하여 키보드 입력을 올바른 요소로 전달

---

### 4. InputLayout 클래스 (신규)

```python
INPUT_WIDTH_PX = 200

class InputLayout:
    """<input>과 <button> 요소를 위한 전용 레이아웃 클래스"""

    def __init__(self, node, parent, previous):
        self.node = node
        self.children = []
        self.parent = parent
        self.previous = previous

    def layout(self):
        """200px 고정 너비, 인라인 위치 계산"""
        weight = self.node.style["font-weight"]
        style = self.node.style["font-style"]
        if style == "normal": style = "roman"
        size = int(float(self.node.style["font-size"][:-2]) * .75)
        self.font = get_font(size, weight, style)

        self.width = INPUT_WIDTH_PX

        if self.previous:
            space = self.previous.font.measure(" ")
            self.x = self.previous.x + space + self.previous.width
        else:
            self.x = self.parent.x

        self.height = self.font.metrics("linespace")

    def paint(self):
        """배경색, 텍스트, 포커스 커서 렌더링"""
        cmds = []

        # 배경색
        bgcolor = self.node.style.get("background-color", "transparent")
        if bgcolor != "transparent":
            cmds.append(DrawRect(self.self_rect(), bgcolor))

        # 텍스트 내용
        if self.node.tag == "input":
            text = self.node.attributes.get("value", "")
        elif self.node.tag == "button":
            if len(self.node.children) == 1 and isinstance(self.node.children[0], Text):
                text = self.node.children[0].text
            else:
                text = ""

        color = self.node.style["color"]
        cmds.append(DrawText(self.x, self.y, text, self.font, color))

        # 포커스 커서 (깜박이는 수직선)
        if self.node.is_focused:
            cx = self.x + self.font.measure(text)
            cmds.append(DrawLine(cx, self.y, cx, self.y + self.height, "black", 1))

        return cmds
```

**주요 기능**:

- ✅ `TextLayout`을 템플릿으로 사용하지만, `word`인수가 없다.
- ✅ 포커스 시 커서 표시
- ✅ CSS 배경색 지원
- ✅ 인라인 배치 (이전 요소와의 간격 자동 계산)

---

### 5. LineLayout 버그 수정

```diff
      max_ascent = max([word.font.metrics("ascent")
-                       for word in self.children])
+                       for word in self.children],
+                       default=0)  # 빈 줄 처리
      baseline = self.y + 1.25 * max_ascent
      for word in self.children:
          word.y = baseline - word.font.metrics("ascent")
      max_descent = max([word.font.metrics("descent")
-                        for word in self.children])
+                        for word in self.children],
+                        default=0)  # 빈 줄 처리
      self.height = 1.25 * (max_ascent + max_descent)

+     def should_paint(self):
+         return True
```

**수정**: `children`이 비어있을 때 `ValueError` 방지

---

### 6. BlockLayout 폼 요소 처리

#### 6-1. layout_mode() - input을 inline으로 취급

```diff
  def layout_mode(self):
      if isinstance(self.node, Text):
          return "inline"
      elif any([isinstance(child, Element) and \
                child.tag in BLOCK_ELEMENTS
                for child in self.node.children]):
          return "block"
-     elif self.node.children:
+     elif self.node.children or self.node.tag == "input":
          return "inline"
      else:
          return "block"
```

**핵심 변경**: `or self.node.tag == "input"` 추가

**왜 필요한가?**

- `<input>` 태그는 **자식 노드가 없는 self-closing 태그**
- 기존 로직: `self.node.children`만 체크 → 자식 없으면 "block" 모드
- 문제: input이 block으로 취급되면 한 줄을 다 차지함
- 해결: input을 명시적으로 inline 모드로 처리

**예시**:

```html
<!-- 원하는 동작: 한 줄에 나란히 배치 -->
Name: <input name="username" /> Age: <input name="age" />

<!-- 만약 block 모드라면: 각 input이 한 줄씩 차지 -->
Name:
<input name="username" />
Age:
<input name="age" />
```

#### 6-2. recurse() - 폼 요소 특별 처리

```diff
  def recurse(self, node):
      if isinstance(node, Text):
          for word in node.text.split():
              self.word(node, word)
      else:
+         if node.tag == "br":
+             self.new_line()  # <br> 태그 처리
+         elif node.tag == "input" or node.tag == "button":
+             self.input(node)  # 입력 요소 처리
+         else:
              for child in node.children:
                  self.recurse(child)
```

```python
def input(self, node):
    """<input>, <button> 요소를 InputLayout으로 생성"""
    w = INPUT_WIDTH_PX

    # 현재 줄에 공간 부족하면 줄바꿈
    if self.cursor_x + w > self.width:
        self.new_line()

    line = self.children[-1]
    previous_word = line.children[-1] if line.children else None
    input = InputLayout(node, line, previous_word)
    line.children.append(input)

    # 커서 위치 이동
    weight = node.style["font-weight"]
    style = node.style["font-style"]
    if style == "normal": style = "roman"
    size = int(float(node.style["font-size"][:-2]) * .75)
    font = get_font(size, weight, style)

    self.cursor_x += w + font.measure(" ")
```

#### 6-3. should_paint() - 중복 렌더링 방지

```diff
  def should_paint(self):
-     return True
+     return isinstance(self.node, Text) or \
+         (self.node.tag != "input" and self.node.tag != "button")
+     # input/button은 InputLayout이 렌더링하므로 제외
```

**핵심 개선**: BlockLayout이 `<input>`, `<button>`을 렌더링하지 않도록 제어

**왜 필요한가?**

렌더링 파이프라인에서 **이중 렌더링 문제** 방지

```python
# paint_tree() 호출 순서
DocumentLayout
  └─ BlockLayout (부모)
      └─ LineLayout
          └─ InputLayout  # 실제 input/button 렌더링

# BlockLayout의 두 가지 역할
1. 구조 관리: input/button을 자식으로 포함
2. 렌더링: 자신의 배경색 등을 그림
```

**문제 상황**:

```python
# BlockLayout.paint()가 항상 호출되면
def paint(self):
    cmds = []
    # input/button의 배경을 그림 (잘못됨!)
    bgcolor = self.node.style.get("background-color", "transparent")
    if bgcolor != "transparent":
        cmds.append(DrawRect(self.self_rect(), bgcolor))
    return cmds

# InputLayout.paint()도 호출됨
# → 같은 input/button이 두 번 렌더링!
```

**해결 방법**:

```python
def should_paint(self):
    # Text 노드는 항상 렌더링
    if isinstance(self.node, Text):
        return True

    # input/button은 InputLayout이 담당하므로 BlockLayout은 건너뜀
    if self.node.tag in ["input", "button"]:
        return False  # BlockLayout은 렌더링 안 함

    # 그 외 Element는 정상 렌더링
    return True
```

**렌더링 흐름**:

```python
# paint_tree() 실행 시
paint_tree(BlockLayout<input>):
    if BlockLayout.should_paint():  # False 반환
        # 여기 실행 안 됨 (중복 방지!)
        pass

    for child in children:
        paint_tree(LineLayout):
            for child in children:
                paint_tree(InputLayout):  # ✅ 여기서만 렌더링
                    # input의 배경, 텍스트, 커서 그림
```

**결과**:

- ✅ `<input>`, `<button>`은 InputLayout에서만 렌더링
- ✅ BlockLayout은 구조 관리만 담당
- ✅ 중복 렌더링 방지
- ✅ 명확한 책임 분리

**예시 비교**:

```python
# should_paint() 없이 (잘못됨)
<input> 렌더링:
  1. BlockLayout.paint() → 배경 그림
  2. InputLayout.paint() → 배경 + 텍스트 + 커서 그림
  결과: 배경이 두 번 그려져서 이상하게 보임

# should_paint() 있음 (올바름)
<input> 렌더링:
  1. BlockLayout.paint() → 건너뜀 (should_paint = False)
  2. InputLayout.paint() → 배경 + 텍스트 + 커서 그림
  결과: 정상적으로 한 번만 렌더링
```

---

### 7. Tab 클래스 폼 제출 기능

#### 7-1. render() 메서드 분리

```diff
  class Tab:
      def __init__(self, tab_height):
          self.scroll = 0
          self.display_list = []
          self.url = None
          self.history = []
          self.tab_height = tab_height
+         self.focus = None  # 포커스된 입력 필드

-     def load(self, url):
+     def load(self, url, payload=None):  # POST 데이터 지원
          self.url = url
          self.history.append(url)
-         body = url.request()
+         body = url.request(payload)
          self.nodes = HTMLParser(body).parse()

-         rules = DEFAULT_STYLE_SHEET.copy()
+         self.rules = DEFAULT_STYLE_SHEET.copy()  # 인스턴스 변수로 저장
          links = [node.attributes["href"]
                   for node in tree_to_list(self.nodes, [])
                   if isinstance(node, Element)
                   and node.tag == "link"
                   and node.attributes.get("rel") == "stylesheet"
                   and "href" in node.attributes]
          for link in links:
              style_url = url.resolve(link)
              try:
                  body = style_url.request()
              except:
                  continue
              rules.extend(CSSParser(body).parse())
-         style(self.nodes, sorted(rules, key=cascade_priority))
-         self.document = DocumentLayout(self.nodes)
-         self.document.layout()
-         self.display_list = []
-         paint_tree(self.document, self.display_list)
+         self.render()  # 렌더링 로직 분리

+     def render(self):
+         """페이지 재렌더링 (입력 필드 업데이트 시 사용)"""
+         style(self.nodes, sorted(self.rules, key=cascade_priority))
+         self.document = DocumentLayout(self.nodes)
+         self.document.layout()
+         self.display_list = []
+         paint_tree(self.document, self.display_list)
```

**핵심 개선**: 데이터 로딩과 렌더링을 분리하여 성능 최적화

#### 왜 render()를 분리했는가?

**관심사의 분리**:

```python
# load(): 데이터 관련 (네트워크, 파싱)
- HTTP 요청 (느림: 수백 ms)
- HTML 파싱
- CSS 다운로드

# render(): 렌더링 관련 (시각적 표현)
- 스타일 계산 (빠름: 수십 ms)
- 레이아웃 계산
- 페인팅 명령 생성
```

**브라우저의 3가지 트리**:

```python
# 1. HTML 트리 (self.nodes)
Element<input>.attributes["value"] = "text"

# 2. 레이아웃 트리 (self.document)
InputLayout:
    .x = 100, .y = 200
    .node = Element<input>  # HTML 트리 참조

# 3. 디스플레이 리스트 (self.display_list)
[DrawText(100, 200, "text", font, color)]
```

**렌더링 파이프라인**:

```python
# HTML 트리 수정만으로는 화면이 바뀌지 않음!
Element<input>.attributes["value"] += "a"  # HTML 트리 수정

# render()가 필요한 이유:
# → 레이아웃 트리 재생성 (새로운 InputLayout)
# → 디스플레이 리스트 재생성 (새로운 DrawText)
# → 화면 업데이트
```

#### self.rules를 인스턴스 변수로 변경

```python
def load(self, url):
    self.rules = DEFAULT_STYLE_SHEET.copy()  # Tab 객체에 저장
    # ...

def render(self):
    # self.rules 재사용! ✅
    style(self.nodes, sorted(self.rules, key=cascade_priority))
```

**장점**: CSS를 다시 다운로드하지 않고 재사용

#### 결론

`render()` 메서드 분리를 통해:

- ✅ **성능**: 네트워크/파싱 없이 렌더링만 재실행 (약 20배 빠름)
- ✅ **관심사 분리**: 데이터 로딩 vs 화면 갱신
- ✅ **재사용성**: `self.nodes`와 `self.rules` 여러 번 재사용
- ✅ **사용자 경험**: 입력 필드에 즉각적인 피드백

이는 실제 브라우저의 **렌더링 파이프라인 최적화** 기법과 동일한 원리

---

#### 7-2. 클릭 이벤트 확장

```diff
  def click(self, x, y):
+     self.focus = None  # 클릭 시 기존 포커스 해제
      y += self.scroll
      objs = [obj for obj in tree_to_list(self.document, [])
          if obj.x <= x < obj.x + obj.width
          and obj.y <= y < obj.y + obj.height]
      if not objs:
          return
      elt = objs[-1].node
      while elt:
          if isinstance(elt, Text):
              pass
          elif elt.tag == "a" and "href" in elt.attributes:
              url = self.url.resolve(elt.attributes["href"])
              return self.load(url)
+         elif elt.tag == "input":
+             # 입력 필드 클릭 처리
+             elt.attributes["value"] = ""  # 값 초기화
+             if self.focus:
+                 self.focus.is_focused = False  # 기존 포커스 해제
+             self.focus = elt
+             elt.is_focused = True
+             return self.render()  # 커서 표시를 위해 재렌더링
+         elif elt.tag == "button":
+             # 버튼 클릭 → 폼 제출
+             while elt:
+                 if elt.tag == "form" and "action" in elt.attributes:
+                     return self.submit_form(elt)
+                 elt = elt.parent
          elt = elt.parent
```

---

#### 7-3. submit_form() 메서드 (신규)

```python
def submit_form(self, elt):
    """폼 제출: 입력 데이터 수집 → URL 인코딩 → POST 요청"""

    # 1. 폼 내의 모든 <input name="..."> 수집
    inputs = [node for node in tree_to_list(elt, [])
              if isinstance(node, Element)
              and node.tag == "input"
              and "name" in node.attributes]

    # 2. name=value 형식으로 데이터 구성
    body = ""
    for input in inputs:
        name = input.attributes["name"]
        value = input.attributes.get("value", "")

        # URL 인코딩 (퍼센트 인코딩)
        # - URL에 사용할 수 없는 문자를 %XX 형식으로 변환
        # - 한글, 공백, 특수문자 등을 안전하게 전송
        # - 예: "홍길동" → "%ED%99%8D%EA%B8%B8%EB%8F%90"
        #      "hello world" → "hello%20world"
        name = urllib.parse.quote(name)
        value = urllib.parse.quote(value)

        body += "&" + name + "=" + value

    body = body[1:]  # 맨 앞의 & 제거

    # 3. POST 요청 전송
    url = self.url.resolve(elt.attributes["action"])
    self.load(url, body)
```

**예시**:

```html
<input name="username" value="홍길동" /> <input name="age" value="25" />
```

↓

```
username=%ED%99%8D%EA%B8%B8%EB%8F%99&age=25
```

---

#### 7-4. keypress() 메서드 (신규)

```python
def keypress(self, char):
    """포커스된 입력 필드에 문자 추가"""
    if self.focus:
        self.focus.attributes["value"] += char
        self.render()  # 화면 업데이트
```

---

### 8. Browser 클래스 포커스 관리

```diff
+ # Browser 클래스에 focus 속성 추가 (Chrome 영역 vs Content 영역)

  def handle_click(self, e):
      if e.y < self.chrome.bottom:
+         self.focus = None  # Chrome 영역 클릭
          self.chrome.click(e.x, e.y)
      else:
+         self.focus = "content"  # Content 영역 클릭
+         self.chrome.blur()  # 주소창 포커스 해제
          tab_y = e.y - self.chrome.bottom
          self.active_tab.click(e.x, tab_y)
      self.draw()
```

```diff
  def handle_key(self, e):
      if len(e.char) == 0: return
      if not (0x20 <= ord(e.char) < 0x7f): return
-     self.chrome.keypress(e.char)
-     self.draw()
+     if self.chrome.keypress(e.char):  # 주소창이 처리했는지 확인
+         self.draw()
+     elif self.focus == "content":  # Content 영역 포커스면
+         self.active_tab.keypress(e.char)  # Tab으로 입력 전달
+         self.draw()
```

**키보드 입력 라우팅**:

1. Chrome(주소창)이 처리하면 → 재렌더링
2. 아니면 content 포커스 확인 → Tab으로 전달
3. 둘 다 아니면 무시

---

### 9. Chrome 클래스 개선

```diff
  def keypress(self, char):
      if self.focus == "address bar":
          self.address_bar += char
+         return True  # 입력 처리 여부 반환
+     return False

+ def blur(self):
+     """포커스 해제"""
+     self.focus = None
```

---

### 10. paint_tree() 함수 수정

```diff
  def paint_tree(layout_object, display_list):
-     display_list.extend(layout_object.paint())
+     if layout_object.should_paint():  # 렌더링 여부 확인
+         display_list.extend(layout_object.paint())

      for child in layout_object.children:
          paint_tree(child, display_list)
```

**목적**: `<input>`, `<button>`은 `BlockLayout`이 아닌 `InputLayout`이 렌더링하도록 제어

---

### 11. 기타 개선

```diff
  # CSS 파일 업데이트
- DEFAULT_STYLE_SHEET = CSSParser(open("browser.css").read()).parse()
+ DEFAULT_STYLE_SHEET = CSSParser(open("browser8.css").read()).parse()
```

```diff
  # 명령줄 인자로 URL 받기
  if __name__ == "__main__":
      import sys
-     Browser().new_tab(URL('https://browser.engineering'))
+     Browser().new_tab(URL(sys.argv[1]))
      tkinter.mainloop()
```

**사용법**: `python browser.py https://example.com`

---

## 전체 아키텍처

### 포커스 관리 계층

```
Browser
├─ focus: None | "content"
├─ Chrome
│  └─ focus: None | "address bar"
└─ Tab
   └─ focus: None | Element 객체
```

### 이벤트 흐름

```
사용자 키 입력
    ↓
Browser.handle_key()
    ↓
Chrome.keypress() → True?
    ↓ No
focus == "content"?
    ↓ Yes
Tab.keypress()
    ↓
Element.attributes["value"] += char
    ↓
Tab.render()
```

### 폼 제출 흐름

```
버튼 클릭
    ↓
Tab.click() → <button> 감지
    ↓
부모로 올라가며 <form> 탐색
    ↓
Tab.submit_form()
    ↓
입력 필드 수집 → URL 인코딩
    ↓
URL.request(payload) → POST 요청
    ↓
서버 응답 → 새 페이지 로드
```

---

## 주요 개선 효과

### ✅ 기능

- POST 요청으로 서버에 데이터 전송
- 키보드로 입력 필드에 문자 입력
- 포커스 상태에 따른 커서 표시
- 버튼 클릭으로 폼 제출

### ✅ 코드 품질

- 렌더링 로직 분리 (`render()` 메서드)
- 책임 분리 (`InputLayout` 전용 클래스)
- 일관된 인터페이스 (`should_paint()`)
- 버그 수정 (빈 children 처리)

### ✅ 사용자 경험

- 실시간 입력 피드백
- 직관적인 포커스 관리
- 빠른 재렌더링 (전체 페이지 재로드 없음)

---

## 결론

이번 변경으로 브라우저가 **정적 문서 뷰어**에서 **상호작용 가능한 웹 애플리케이션**으로 진화했습니다.

**핵심 개념**:

1. **HTTP POST**: 서버로 데이터 전송
2. **포커스 관리**: 입력을 올바른 요소로 라우팅
3. **재렌더링**: 상태 변경 시 효율적 화면 업데이트
4. **레이아웃 시스템**: 요소별 전용 레이아웃 클래스

---

[Form 변화](bonus-notes/form.md)
