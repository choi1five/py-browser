# 사용자 데이터 보호하기

**쿠키(Cookie) 관리**, **Content Security Policy (CSP)**, 그리고 **XMLHttpRequest (XHR)** 지원을 추가하여 사용자 데이터를 보호하고 웹 보안을 강화했습니다.

## 변경사항

### 1. 쿠키 저장소 추가

```python
# 브라우저의 쿠키 저장소 (전역)
# 각 웹사이트(호스트)별로 쿠키를 저장
# 예: COOKIE_JAR["example.com"] = ("session=abc123", {"samesite": "lax"})
COOKIE_JAR = {}
```

**설명**:

- 전역 딕셔너리 `COOKIE_JAR`를 추가하여 호스트별 쿠키를 저장합니다.
- 키: 호스트 이름, 값: `(cookie, params)` 튜플

**의도**:
서버가 보낸 쿠키를 저장하고, 같은 호스트로 요청할 때 쿠키를 자동으로 전송하기 위한 기반을 마련했습니다.

---

### 2. Origin 식별 메서드 추가

```python
# URL의 출처(origin)를 반환
# origin = 프로토콜 + 호스트 + 포트
# 예: "https://example.com:443"
# Same-Origin Policy에서 두 URL이 같은 출처인지 비교할 때 사용
def origin(self):
    return self.scheme + "://" + self.host + ":" + str(self.port)
```

**설명**:

- URL의 origin(출처)을 반환하는 메서드
- Origin은 `scheme://host:port` 형식

**의도**:
Same-Origin Policy (동일 출처 정책)를 구현하기 위해 URL의 origin을 쉽게 비교할 수 있도록 했습니다.
XHR이나 CSP 검증에서 사용

---

### 3. HTTP 요청 메서드 개선 (쿠키 송수신)

```python
# referrer: 요청을 시작한 페이지의 URL
def request(self, referrer, payload=None):
    ...
    request += "Host: {}\r\n".format(self.host)

    # 저장된 쿠키 확인
    if self.host in COOKIE_JAR:
        cookie, params = COOKIE_JAR[self.host]  # 쿠키와 설정값 가져옴
        allow_cookie = True  # 기본: 쿠키 전송 허용

        # SameSite=Lax 쿠키의 CSRF 방지 로직
        # 다른 사이트에서 온 POST 요청에는 쿠키 전송 안 함
        if referrer and params.get("samesite", "none") == "lax":
            if method != "GET":  # POST, PUT 등
                # 같은 사이트만 쿠키 전송 허용
                allow_cookie = self.host == referrer.host

        # 쿠키 허용 시 HTTP 헤더에 추가
        if allow_cookie:
            request += "Cookie: {}\r\n".format(cookie)
```

**설명**:

1. **referrer 매개변수 추가**: 요청을 시작한 페이지의 URL 정보
2. **쿠키 전송 로직**:
   - `COOKIE_JAR`에 해당 호스트의 쿠키가 있으면 전송
   - `SameSite=Lax` 속성이 있고 POST 요청인 경우, referrer의 호스트와 현재 호스트가 같을 때만 쿠키 전송
   - CSRF(Cross-Site Request Forgery) 공격 방지

```python
# Set-Cookie 헤더 확인
if "set-cookie" in response_headers:
    cookie = response_headers["set-cookie"]
    params = {}  # 쿠키 속성 저장 (SameSite, HttpOnly 등)

    # 쿠키 문자열 파싱
    # 예: "session=abc123; SameSite=Lax; HttpOnly"
    if ";" in cookie:
        # 쿠키 값과 속성 분리
        # cookie = "session=abc123"
        # rest = "SameSite=Lax; HttpOnly"
        cookie, rest = cookie.split(";", 1)

        # 각 속성 파싱
        for param in rest.split(";"):
            if '=' in param:
                # 키-값 쌍: "SameSite=Lax"
                param, value = param.split("=", 1)
            else:
                # 불리언 플래그: "HttpOnly"
                value = "true"

            # 소문자 변환하여 저장 (대소문자 구분 없이 비교)
            params[param.strip().casefold()] = value.casefold()

    # 호스트별 쿠키 저장
    # 다음 요청 시 자동 전송됨
    COOKIE_JAR[self.host] = (cookie, params)
```

**설명**:

- 서버 응답에서 `Set-Cookie` 헤더를 파싱합니다.
- 쿠키 값과 속성(SameSite, HttpOnly 등)을 분리하여 저장합니다.

```python
# 응답 헤더와 본문 모두 반환 (기존: 본문만)
# CSP, Set-Cookie 같은 보안 헤더 확인용
return response_headers, content
```

**설명**:

- 기존에는 body만 반환했지만, 이제 response_headers도 함께 반환합니다.
- CSP 헤더나 Set-Cookie 헤더를 사용하기 위해 필요합니다.

**의도**:

- **세션 관리**: 로그인 상태 유지 등을 위한 쿠키 기능 구현
- **CSRF 방지**: SameSite 속성을 통해 크로스 사이트 요청에서의 쿠키 전송을 제한
- **보안 강화**: 응답 헤더를 통해 보안 정책(CSP 등)을 적용할 수 있게 함

---

### 4. XMLHttpRequest 지원 추가

```python
# JavaScript에서 XMLHttpRequest 사용 가능하도록 Python 함수 연결
# JavaScript의 XMLHttpRequest_send() 호출 시 이 메서드 실행됨
self.interp.export_function("XMLHttpRequest_send",
                            self.XMLHttpRequest_send)
```

```python
# JavaScript XMLHttpRequest 처리 (AJAX 요청)
def XMLHttpRequest_send(self, method, url, body):
    # 상대 경로 -> 절대 경로 변환
    # 예: "/api/data" -> "https://example.com/api/data"
    full_url = self.tab.url.resolve(url)

    # CSP 검증: URL 요청 가능 여부 확인
    # CSP 차단 origin이면 예외 발생
    if not self.tab.allowed_request(full_url):
        raise Exception("Cross-origin XHR blocked by CSP")

    # HTTP 요청 실행
    headers, out = full_url.request(self.tab.url, body)

    # Same-Origin Policy 검증
    # XHR은 같은 origin만 허용 (CORS 미구현)
    # 예: https://example.com -> https://other.com 불가
    if full_url.origin() != self.tab.url.origin():
        raise Exception("Cross-origin XHR request not allowed")

    # 응답 반환
    return out
```

**설명**:

1. JavaScript에서 XMLHttpRequest를 사용할 수 있도록 `XMLHttpRequest_send` 함수를 export
2. **CSP 검증**: CSP 정책에 따라 요청이 허용되는지 확인
3. **Same-Origin Policy**: XHR은 동일한 origin으로만 요청 가능 (CORS 미구현)
4. 요청 성공 시 응답 본문 반환

**의도**:

- **동적 데이터 로드**: JavaScript가 페이지를 새로고침하지 않고 서버와 통신할 수 있게 함
- **보안 검증**: CSP와 Same-Origin Policy를 통해 악의적인 요청을 차단

---

### 5. Content Security Policy (CSP) 구현

```python
# CSP에 따라 URL 요청 가능 여부 확인
def allowed_request(self, url):
    # CSP 미설정(None): 모든 요청 허용
    # CSP 있음: 허용된 origin 목록 확인
    return self.allowed_origins == None or \
        url.origin() in self.allowed_origins
```

```python
def load(self, url, payload=None):
    # HTTP 요청 후 응답 헤더와 본문 수신
    headers, body = url.request(self.url, payload)

    # 방문 기록 추가 (뒤로가기용)
    self.history.append(url)
    self.url = url

    # CSP 초기화: 기본 모든 리소스 허용
    self.allowed_origins = None

    # CSP 헤더 확인
    # 예: "Content-Security-Policy: default-src https://example.com https://cdn.example.com"
    if "content-security-policy" in headers:
        # CSP 문자열 공백 분리
        # ["default-src", "https://example.com", "https://cdn.example.com"]
        csp = headers["content-security-policy"].split()

        # default-src 지시문 확인
        if len(csp) > 0 and csp[0] == "default-src":
            # 허용 origin 목록 생성
            self.allowed_origins = []

            # default-src 이후 모든 origin 추가
            # csp[1:] = ["https://example.com", "https://cdn.example.com"]
            for origin in csp[1:]:
                # origin 정규화 후 추가
                # "https://example.com" -> "https://example.com:443"
                self.allowed_origins.append(URL(origin).origin())
```

**설명**:

1. **CSP 헤더 파싱**: `Content-Security-Policy: default-src` 지시문을 파싱
2. **허용된 origin 리스트 생성**: CSP에 명시된 origin들만 허용
3. **allowed_request 메서드**: 요청하려는 URL이 허용된 origin인지 검증

```python
# 외부 스크립트 로드
for script in scripts:
    # 상대 경로 -> 절대 경로
    # 예: "script.js" -> "https://example.com/script.js"
    script_url = url.resolve(script)

    # CSP 검증: 스크립트 로드 가능 여부 확인
    # CSP 미허용 origin이면 차단
    if not self.allowed_request(script_url):
        print("Blocked script", script, "due to CSP")
        continue  # 건너뜀

    # 스크립트 파일 다운로드
    try:
        headers, body = script_url.request(url)
```

```python
# 외부 스타일시트 로드
for link in links:
    # 상대 경로 -> 절대 경로
    style_url = url.resolve(link)

    # CSP 검증: 스타일시트 로드 가능 여부 확인
    if not self.allowed_request(style_url):
        print("Blocked style", link, "due to CSP")
        continue  # 건너뜀

    # 스타일시트 파일 다운로드
    try:
        headers, body = style_url.request(url)
```

**설명**:

- 외부 스크립트와 스타일시트를 로드하기 전에 CSP 정책을 확인합니다.
- 허용되지 않은 origin의 리소스는 차단하고 콘솔에 메시지를 출력합니다.

**의도**:

- **XSS 공격 방지**: 허용되지 않은 외부 스크립트가 실행되는 것을 차단
- **데이터 유출 방지**: 신뢰할 수 없는 외부 서버로의 요청을 제한
- **보안 정책 강제**: 서버가 정의한 보안 정책을 브라우저가 강제 적용

---

## 전체적인 변경 의도

### 1. **쿠키 기반 세션 관리**

웹 애플리케이션의 필수 기능인 로그인/세션 상태 유지를 위해 쿠키를 구현했습니다. SameSite 속성을 통해 CSRF 공격도 방지합니다.

### 2. **Content Security Policy (CSP)**

XSS(Cross-Site Scripting) 공격을 방지하기 위한 주요 방어 메커니즘입니다. 서버가 신뢰하는 origin의 리소스만 로드할 수 있도록 제한합니다.

### 3. **XMLHttpRequest 지원**

현대 웹의 동적 기능(AJAX)을 지원하면서도 Same-Origin Policy로 보안을 유지합니다.

### 4. **보안 계층화 (Defense in Depth)**

- **쿠키 SameSite**: CSRF 방지
- **CSP**: XSS 방지
- **Same-Origin Policy**: 데이터 유출 방지
- 여러 보안 메커니즘을 겹쳐서 사용자 데이터를 다층적으로 보호합니다.

---

## 보안 관련 핵심 개념

### Same-Origin Policy (동일 출처 정책)

- **Origin = scheme + host + port**
- `https://example.com:443`과 `http://example.com:80`은 다른 origin
- XHR은 같은 origin으로만 요청 가능

### CSRF (Cross-Site Request Forgery)

- 사용자가 의도하지 않은 요청을 악의적 사이트가 대신 보내는 공격
- SameSite=Lax 쿠키로 방어: 크로스 사이트 POST 요청에는 쿠키를 보내지 않음

### XSS (Cross-Site Scripting)

- 악의적인 스크립트를 웹페이지에 삽입하는 공격
- CSP로 방어: 허용된 origin의 스크립트만 실행

---

[Timing Attack](bonus-notes/timing-attack.md)
[CSRF](bonus-notes/csrf.md)
[MITM](bonus-notes/mitm.md)
[XSS & CSP](bonus-notes/xss_csp.md)
