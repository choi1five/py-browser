# 시각적 효과 (Visual Effects)

## 주요 변경사항

### 1. UI 라이브러리 전환: Tkinter → SDL2 + Skia

#### 변경된 import

```diff
+import ctypes
+import math
+import sdl2
+import skia
 import socket
 import ssl
-import tkinter
-import tkinter.font
 import urllib.parse
```

**이유**: Skia는 Chrome 브라우저가 실제로 사용하는 2D 그래픽 라이브러리로, 더 강력한 시각적 효과(opacity, blend modes, anti-aliasing 등)를 지원합니다.

---

### 2. 폰트 처리 개선

#### 이전 코드 (Tkinter)

```python
def get_font(size, weight, style):
    key = (size, weight, style)
    if key not in FONTS:
        font = tkinter.font.Font(size=size, weight=weight, slant=style)
        label = tkinter.Label(font=font)
        FONTS[key] = (font, label)
    return FONTS[key][0]
```

#### 개선된 코드 (Skia)

```python
def get_font(size, weight, style):
    # 폰트 캐싱 최적화: size를 key에서 제외하여 캐시 효율성 증대
    key = (weight, style)
    if key not in FONTS:
        # weight 매핑: "bold" → skia.FontStyle.kBold_Weight
        if weight == "bold":
            skia_weight = skia.FontStyle.kBold_Weight
        else:
            skia_weight = skia.FontStyle.kNormal_Weight

        # style 매핑: "italic" → skia.FontStyle.kItalic_Slant
        if style == "italic":
            skia_style = skia.FontStyle.kItalic_Slant
        else:
            skia_style = skia.FontStyle.kUpright_Slant

        skia_width = skia.FontStyle.kNormal_Width
        style_info = skia.FontStyle(skia_weight, skia_width, skia_style)
        font = skia.Typeface('Arial', style_info)
        FONTS[key] = font

    # Typeface를 재사용하고 size만 적용
    return skia.Font(FONTS[key], size)
```

**개선 포인트**:

- 캐싱 전략 변경: (size, weight, style) → (weight, style)
- size를 제외함으로써 캐시 효율성 증가
- Typeface와 Font를 분리하여 관리

#### linespace 함수 추가

```python
def linespace(font):
    """폰트의 줄 간격을 계산 (ascent + descent)"""
    metrics = font.getMetrics()
    return metrics.fDescent - metrics.fAscent
```

---

### 3. 색상 처리 시스템

#### 색상 이름 매핑

```python
NAMED_COLORS = {
    "black": "#000000",
    "gray":  "#808080",
    "white": "#ffffff",
    "red":   "#ff0000",
    "green": "#00ff00",
    "blue":  "#0000ff",
    "lightblue": "#add8e6",
    "lightgreen": "#90ee90",
    "orange": "#ffa500",
    "orangered": "#ff4500",
}
```

#### parse_color 함수

```python
def parse_color(color):
    """CSS 색상 문자열을 Skia Color 객체로 변환"""
    # Hex 색상 처리 (#RRGGBB)
    if color.startswith("#") and len(color) == 7:
        r = int(color[1:3], 16)  # 16진수 → 10진수 변환
        g = int(color[3:5], 16)
        b = int(color[5:7], 16)
        return skia.Color(r, g, b)
    # 색상 이름 처리 (재귀적으로 hex로 변환)
    elif color in NAMED_COLORS:
        return parse_color(NAMED_COLORS[color])
    else:
        return skia.ColorBLACK
```

---

### 4. 시각적 효과 시스템 ⭐️ 핵심 기능

#### paint_visual_effects 함수

```python
def paint_visual_effects(node, cmds, rect):
    """노드에 opacity와 blend mode 시각적 효과를 적용"""

    # CSS opacity 속성 읽기 (기본값: 1.0 = 불투명)
    opacity = float(node.style.get("opacity", "1.0"))

    # CSS mix-blend-mode 속성 읽기
    blend_mode = node.style.get("mix-blend-mode")

    # overflow: clip 처리 (border-radius와 함께 사용)
    if node.style.get("overflow", "visible") == "clip":
        border_radius = float(node.style.get("border-radius", "0px")[:-2])

        # blend_mode가 없으면 기본값 설정
        if not blend_mode:
            blend_mode = "source-over"

        # destination-in 블렌드 모드로 clipping mask 생성
        # 둥근 사각형(RRect) 모양으로 내용을 자름
        cmds.append(Blend(1.0, "destination-in", [
            DrawRRect(rect, border_radius, "white")
        ]))

    # 모든 명령어를 Blend 객체로 감싸서 반환
    return [Blend(opacity, blend_mode, cmds)]
```

**작동 원리**:

1. `opacity`: 요소의 투명도 제어 (0.0=완전투명, 1.0=불투명)
2. `mix-blend-mode`: 요소가 배경과 혼합되는 방식 제어
3. `overflow: clip` + `border-radius`: 둥근 모서리로 내용 잘라내기

---

### 5. Blend 클래스 ⭐️ 핵심 기능

```python
class Blend:
    """opacity와 blend mode를 적용하는 컨테이너"""

    def __init__(self, opacity, blend_mode, children):
        self.opacity = opacity
        self.blend_mode = blend_mode

        # 최적화: 효과가 필요한 경우만 saveLayer 사용
        self.should_save = self.blend_mode or self.opacity < 1

        self.children = children  # 자식 draw 명령어들

        # 모든 자식의 rect를 포함하는 bounding box 계산
        self.rect = skia.Rect.MakeEmpty()
        for cmd in self.children:
            self.rect.join(cmd.rect)

    def execute(self, canvas):
        """Skia canvas에 블렌딩 효과 적용"""
        # Paint 객체 생성: opacity와 blend mode 설정
        paint = skia.Paint(
            Alphaf=self.opacity,  # Alpha 채널 (투명도)
            BlendMode=parse_blend_mode(self.blend_mode),
        )

        # saveLayer: 오프스크린 버퍼에 렌더링 후 블렌딩
        # 성능 최적화를 위해 필요한 경우만 사용
        if self.should_save:
            canvas.saveLayer(None, paint)

        # 자식 명령어들 실행
        for cmd in self.children:
            cmd.execute(canvas)

        # canvas 상태 복원
        if self.should_save:
            canvas.restore()
```

#### parse_blend_mode 함수

```python
def parse_blend_mode(blend_mode_str):
    """CSS blend mode 문자열을 Skia BlendMode enum으로 변환"""
    if blend_mode_str == "multiply":
        return skia.BlendMode.kMultiply  # 곱셈 블렌딩
    elif blend_mode_str == "difference":
        return skia.BlendMode.kDifference  # 차이 블렌딩
    elif blend_mode_str == "destination-in":
        return skia.BlendMode.kDstIn  # 목적지 내부만 표시 (마스킹)
    elif blend_mode_str == "source-over":
        return skia.BlendMode.kSrcOver  # 일반 알파 블렌딩
    else:
        return skia.BlendMode.kSrcOver  # 기본값
```

**Blend Mode 설명**:

- `multiply`: 색상 곱셈 (어두운 효과)
- `difference`: 색상 차이 계산 (반전 효과)
- `destination-in`: 마스킹 용도 (clipping에 사용)
- `source-over`: 표준 알파 블렌딩 (기본값)

---

### 6. border-radius 지원

#### DrawRRect 클래스 추가

```python
class DrawRRect:
    """둥근 모서리 사각형(Rounded Rectangle) 그리기"""

    def __init__(self, rect, radius, color):
        self.rect = rect
        # RRect 생성: X/Y 방향 모두 같은 radius 적용
        self.rrect = skia.RRect.MakeRectXY(rect, radius, radius)
        self.color = color

    def execute(self, canvas):
        paint = skia.Paint(
            Color=parse_color(self.color),
        )
        canvas.drawRRect(self.rrect, paint)
```

#### 사용 예시 (InputLayout/BlockLayout)

```python
def paint(self):
    cmds = []
    bgcolor = self.node.style.get("background-color", "transparent")
    if bgcolor != "transparent":
        # border-radius 추출 및 적용
        radius = float(self.node.style.get("border-radius", "0px")[:-2])
        cmds.append(DrawRRect(self.self_rect(), radius, bgcolor))
    # ...
```

---

### 7. 렌더링 파이프라인 개선

#### paint_tree 함수 수정

```python
def paint_tree(layout_object, display_list):
    """레이아웃 트리를 순회하며 display list 생성"""
    cmds = []

    # Phase 1: 요소 자체 그리기 (배경 등)
    if layout_object.should_paint():
        cmds = layout_object.paint()

    # Phase 2: 자식 요소들 재귀적으로 처리
    for child in layout_object.children:
        paint_tree(child, cmds)

    # Phase 3: 시각적 효과 적용 (opacity, blend mode, clipping)
    # ⭐️ 중요: paint_effects는 자식들이 모두 렌더링된 후 적용!
    if layout_object.should_paint():
        cmds = layout_object.paint_effects(cmds)

    display_list.extend(cmds)
```

**렌더링 순서**:

1. 부모 배경 그리기
2. 자식들 그리기 (재귀)
3. 부모의 시각 효과 적용 (자식들을 포함하여)

#### paint_effects 메소드 추가

모든 레이아웃 클래스에 `paint_effects` 메소드 추가:

```python
# LineLayout, InputLayout, TextLayout
def paint_effects(self, cmds):
    return cmds  # 효과 없이 그대로 반환

# BlockLayout만 실제 효과 적용
def paint_effects(self, cmds):
    cmds = paint_visual_effects(
        self.node, cmds, self.self_rect())
    return cmds
```

---

### 8. Drawing Commands 개선

#### execute 메소드 시그니처 변경

```diff
# 이전: scroll 파라미터를 받아서 직접 스크롤 계산
-def execute(self, scroll, canvas):
-    canvas.create_text(
-        self.rect.left, self.rect.top - scroll, ...)

# 개선: scroll은 canvas transform으로 처리
+def execute(self, canvas):
+    canvas.drawString(self.text,
+        float(self.rect.left()), baseline, ...)
```

**개선 이유**:

- 스크롤을 canvas의 `translate()`로 처리하여 코드 단순화
- 각 drawing command가 scroll을 신경 쓸 필요 없음

#### DrawText 개선

```python
class DrawText:
    def __init__(self, x1, y1, text, font, color):
        # rect 계산: 텍스트의 정확한 bounding box
        self.rect = skia.Rect.MakeLTRB(
            x1, y1,
            x1 + font.measureText(text),  # 텍스트 너비
            y1 - font.getMetrics().fAscent \  # ascent (위쪽)
                + font.getMetrics().fDescent)  # descent (아래쪽)
        self.text = text
        self.font = font
        self.color = color

    def execute(self, canvas):
        paint = skia.Paint(
            AntiAlias=True,  # 안티 앨리어싱으로 부드러운 텍스트
            Color=parse_color(self.color),
        )
        # baseline 계산: y 좌표에서 ascent만큼 올라감
        baseline = self.rect.top() - self.font.getMetrics().fAscent
        canvas.drawString(self.text, float(self.rect.left()),
            baseline, self.font, paint)
```

---

### 9. 브라우저 렌더링 아키텍처 변경

#### 이전 (Tkinter): 단일 canvas에 직접 그리기

```python
def draw(self):
    self.canvas.delete("all")  # 전체 삭제
    self.active_tab.draw(self.canvas, self.chrome.bottom)
    for cmd in self.chrome.paint():
        cmd.execute(0, self.canvas)
```

#### 개선 (SDL2/Skia): 3개의 Surface로 분리

```python
def __init__(self):
    # Surface 1: 최종 출력용 root surface
    self.root_surface = skia.Surface.MakeRaster(
        skia.ImageInfo.Make(WIDTH, HEIGHT,
            ct=skia.kRGBA_8888_ColorType,
            at=skia.kUnpremul_AlphaType))

    # Surface 2: Chrome UI (주소 바, 탭 등)
    self.chrome_surface = skia.Surface(
        WIDTH, math.ceil(self.chrome.bottom))

    # Surface 3: 활성 탭의 content (동적 크기)
    self.tab_surface = None
```

#### raster_tab: 탭 content를 surface에 렌더링

```python
def raster_tab(self):
    """활성 탭의 content를 tab_surface에 렌더링"""

    # 탭 content 높이 계산 (document 높이 + padding)
    tab_height = math.ceil(
        self.active_tab.document.height + 2*VSTEP)

    # surface 크기가 변경되었으면 재생성
    if not self.tab_surface or \
            tab_height != self.tab_surface.height():
        self.tab_surface = skia.Surface(WIDTH, tab_height)

    canvas = self.tab_surface.getCanvas()
    canvas.clear(skia.ColorWHITE)

    # display list의 모든 명령어 실행
    self.active_tab.raster(canvas)
```

#### raster_chrome: Chrome UI를 surface에 렌더링

```python
def raster_chrome(self):
    """Chrome UI를 chrome_surface에 렌더링"""
    canvas = self.chrome_surface.getCanvas()
    canvas.clear(skia.ColorWHITE)

    for cmd in self.chrome.paint():
        cmd.execute(canvas)
```

#### draw: 모든 surface를 합성하여 화면에 출력

```python
def draw(self):
    """3개의 surface를 합성하여 최종 화면 생성"""
    canvas = self.root_surface.getCanvas()
    canvas.clear(skia.ColorWHITE)

    # ===== Part 1: 탭 content 그리기 (스크롤 적용) =====
    tab_rect = skia.Rect.MakeLTRB(
        0, self.chrome.bottom, WIDTH, HEIGHT)

    # 스크롤 offset 계산
    tab_offset = self.chrome.bottom - self.active_tab.scroll

    canvas.save()  # canvas 상태 저장
    canvas.clipRect(tab_rect)  # 탭 영역으로 clipping
    canvas.translate(0, tab_offset)  # 스크롤 적용
    self.tab_surface.draw(canvas, 0, 0)  # surface 복사
    canvas.restore()  # canvas 상태 복원

    # ===== Part 2: Chrome UI 그리기 (스크롤 없음) =====
    chrome_rect = skia.Rect.MakeLTRB(
        0, 0, WIDTH, self.chrome.bottom)

    canvas.save()
    canvas.clipRect(chrome_rect)  # Chrome 영역으로 clipping
    self.chrome_surface.draw(canvas, 0, 0)
    canvas.restore()

    # ===== Part 3: Skia surface를 SDL surface로 변환 =====
    skia_image = self.root_surface.makeImageSnapshot()
    skia_bytes = skia_image.tobytes()  # 픽셀 데이터 추출

    depth = 32  # 픽셀당 32비트 (RGBA)
    pitch = 4 * WIDTH  # 행당 바이트 수

    # SDL surface 생성 (Skia 데이터 재사용)
    sdl_surface = sdl2.SDL_CreateRGBSurfaceFrom(
        skia_bytes, WIDTH, HEIGHT, depth, pitch,
        self.RED_MASK, self.GREEN_MASK,
        self.BLUE_MASK, self.ALPHA_MASK)

    # SDL window에 복사 (더블 버퍼링)
    rect = sdl2.SDL_Rect(0, 0, WIDTH, HEIGHT)
    window_surface = sdl2.SDL_GetWindowSurface(self.sdl_window)
    sdl2.SDL_BlitSurface(sdl_surface, rect, window_surface, rect)
    sdl2.SDL_UpdateWindowSurface(self.sdl_window)
```

**3-Surface 아키텍처의 장점**:

1. **성능**: 변경되지 않은 surface는 재렌더링 불필요
2. **독립성**: Chrome UI와 content를 독립적으로 업데이트
3. **스크롤**: tab_surface만 translate하여 효율적인 스크롤

---

### 10. 이벤트 처리 개선

#### 이전 (Tkinter)

```python
self.window.bind("<Down>", self.handle_down)
self.window.bind("<Button-1>", self.handle_click)
self.window.bind("<Key>", self.handle_key)
self.window.bind("<Return>", self.handle_enter)
```

#### 개선 (SDL2)

```python
def mainloop(browser):
    """SDL2 이벤트 루프"""
    event = sdl2.SDL_Event()
    while True:
        # 이벤트 폴링 (non-blocking)
        while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:
            if event.type == sdl2.SDL_QUIT:
                browser.handle_quit()
                sdl2.SDL_Quit()
                sys.exit()
            elif event.type == sdl2.SDL_MOUSEBUTTONUP:
                browser.handle_click(event.button)
            elif event.type == sdl2.SDL_KEYDOWN:
                # 특수 키 처리
                if event.key.keysym.sym == sdl2.SDLK_RETURN:
                    browser.handle_enter()
                elif event.key.keysym.sym == sdl2.SDLK_DOWN:
                    browser.handle_down()
            elif event.type == sdl2.SDL_TEXTINPUT:
                # 텍스트 입력 처리 (UTF-8 지원)
                browser.handle_key(event.text.text.decode('utf8'))
```

**개선점**:

- `SDL_TEXTINPUT`과 `SDL_KEYDOWN` 분리로 국제화 지원
- 명시적인 이벤트 루프로 더 나은 제어

---

### 11. Rect 처리 개선

#### 이전: 커스텀 Rect 클래스

```python
class Rect:
    def __init__(self, left, top, right, bottom):
        self.left = left
        self.top = top
        self.right = right
        self.bottom = bottom

    def contains_point(self, x, y):
        return x >= self.left and x < self.right \
            and y >= self.top and y < self.bottom
```

#### 개선: Skia의 Rect 사용

```python
# 생성
rect = skia.Rect.MakeLTRB(left, top, right, bottom)

# 접근 (메소드 호출)
rect.left()
rect.top()
rect.right()
rect.bottom()

# 포함 여부 확인
rect.contains(x, y)
```

**변경 이유**:

- Skia API와의 일관성
- 최적화된 네이티브 구현
- 추가 기능 (join, intersect 등)

---

### 12. 폰트 메트릭 처리

#### Tkinter → Skia 변환

```diff
# 텍스트 너비 측정
-self.font.measure(text)
+self.font.measureText(text)

# 폰트 메트릭 접근
-self.font.metrics("ascent")
-self.font.metrics("descent")
-self.font.metrics("linespace")
+self.font.getMetrics().fAscent  # 음수 값!
+self.font.getMetrics().fDescent  # 양수 값
+linespace(self.font)  # helper 함수
```

**주의**: Skia의 `fAscent`는 음수, `fDescent`는 양수입니다!

---

## 성능 최적화 포인트

### 1. Surface 분리

- Chrome UI와 content를 별도 surface에 렌더링
- 변경되지 않은 surface는 재사용

### 2. 폰트 캐싱

- (weight, style)만 캐싱하고 size는 동적 적용
- 메모리 효율성 증가

### 3. saveLayer 최적화

```python
self.should_save = self.blend_mode or self.opacity < 1
```

- 효과가 필요한 경우만 오프스크린 렌더링
- 불필요한 saveLayer 호출 방지

### 4. Selective Repaint

```python
# 특정 영역만 다시 렌더링
if self.active_tab.url != url:
    self.raster_chrome()
self.raster_tab()
self.draw()
```

---

## 시각적 효과 사용 예시

### Opacity (투명도)

```css
div {
  opacity: 0.5; /* 50% 투명 */
}
```

### Blend Mode (혼합 모드)

```css
div {
  mix-blend-mode: multiply; /* 곱셈 블렌딩 */
}
```

### Border Radius (둥근 모서리)

```css
div {
  border-radius: 10px;
  background-color: blue;
}
```

### Overflow Clipping

```css
div {
  overflow: clip;
  border-radius: 20px;
  /* 자식 요소가 둥근 모서리로 잘림 */
}
```

---

## 디버깅 팁

### 1. Surface 디버깅

```python
# Surface를 파일로 저장
image = surface.makeImageSnapshot()
image.save('debug.png', skia.kPNG)
```

### 2. Rect 시각화

```python
# Rect 경계 그리기
canvas.drawRect(rect, skia.Paint(
    Color=skia.ColorRED,
    Style=skia.Paint.kStroke_Style
))
```

### 3. Blend Mode 테스트

```python
# 단순한 blend mode부터 테스트
Blend(1.0, "source-over", cmds)  # 기본값
Blend(0.5, None, cmds)  # opacity만
Blend(1.0, "multiply", cmds)  # blend mode만
```
