# 태스크와 스레드 스케쥴링

## 개요

이번 변경에서는 브라우저에 멀티스레딩 시스템을 도입하여 UI 응답성을 개선하고, 비동기 JavaScript 기능(setTimeout, 비동기 XHR, requestAnimationFrame)을 지원합니다.

## 주요 변경사항

### 1. TaskRunner 및 Task 시스템 도입

**목적**: 탭마다 독립적인 메인 스레드를 운영하여 JavaScript 실행, 렌더링 등의 작업을 비동기적으로 처리

```diff
+class Task:
+    def __init__(self, task_code, *args):
+        self.task_code = task_code  # 실행할 함수
+        self.args = args            # 함수 인자
+
+    def run(self):
+        self.task_code(*self.args)  # 태스크 실행
+        self.task_code = None       # 메모리 해제
+        self.args = None
```

```diff
+class TaskRunner:
+    def __init__(self, tab):
+        self.tab = tab
+        self.tasks = []                          # 태스크 큐
+        self.condition = threading.Condition()   # 스레드 동기화 도구
+        self.main_thread = threading.Thread(
+            target=self.run,
+            name="Main thread",
+        )
+        self.needs_quit = False
+
+    def schedule_task(self, task):
+        """태스크를 큐에 추가하고 스레드를 깨움"""
+        self.condition.acquire(blocking=True)
+        self.tasks.append(task)
+        self.condition.notify_all()              # 대기 중인 스레드 깨우기
+        self.condition.release()
+
+    def run(self):
+        """메인 스레드 루프: 태스크를 하나씩 꺼내서 실행"""
+        while True:
+            self.condition.acquire(blocking=True)
+            needs_quit = self.needs_quit
+            self.condition.release()
+            if needs_quit:
+                self.handle_quit()
+                return
+
+            task = None
+            self.condition.acquire(blocking=True)
+            if len(self.tasks) > 0:
+                task = self.tasks.pop(0)         # FIFO 방식으로 태스크 꺼내기
+            self.condition.release()
+            if task:
+                task.run()
+
+            self.condition.acquire(blocking=True)
+            if len(self.tasks) == 0 and not self.needs_quit:
+                self.condition.wait()            # 태스크가 없으면 대기
+            self.condition.release()
```

**핵심 개념**:

- `threading.Condition`: Lock + 조건 변수. 스레드 간 동기화와 대기/깨우기 기능 제공
- `wait()`: 락을 해제하고 대기 상태로 전환
- `notify_all()`: 대기 중인 모든 스레드 깨우기

### 2. JavaScript 비동기 기능 구현

#### setTimeout 구현

**runtime.js**:

```diff
+SET_TIMEOUT_REQUESTS = {};
+
+function setTimeout(callback, time_delta) {
+  var handle = Object.keys(SET_TIMEOUT_REQUESTS).length;  // 고유 핸들 생성
+  SET_TIMEOUT_REQUESTS[handle] = callback;                // 콜백 저장
+  call_python("setTimeout", handle, time_delta);          // Python에 타이머 요청
+}
+
+function __runSetTimeout(handle) {
+  var callback = SET_TIMEOUT_REQUESTS[handle];
+  callback();                                              // 콜백 실행
+}
```

**browser.py**:

```diff
+SETTIMEOUT_JS = "__runSetTimeout(dukpy.handle)"
+
 class JSContext:
     def __init__(self, tab):
+        self.interp.export_function("setTimeout",
+            self.setTimeout)
+
+    def setTimeout(self, handle, time):
+        def run_callback():
+            task = Task(self.dispatch_settimeout, handle)
+            self.tab.task_runner.schedule_task(task)      # 태스크 큐에 추가
+        threading.Timer(time / 1000.0, run_callback).start()  # 타이머 시작
+
+    def dispatch_settimeout(self, handle):
+        if self.discarded: return                         # 탭이 닫혔으면 무시
+        self.interp.evaljs(SETTIMEOUT_JS, handle=handle)  # JS 콜백 실행
```

**동작 흐름**:

1. JS에서 `setTimeout(callback, 1000)` 호출
2. Python의 `threading.Timer`로 1초 후 실행 예약
3. 1초 후 `run_callback`이 새 스레드에서 실행됨
4. TaskRunner의 큐에 태스크 추가
5. 탭의 메인 스레드가 태스크를 꺼내서 실행
6. `__runSetTimeout`이 JS 콜백 호출

#### 비동기 XMLHttpRequest 구현

**runtime.js**:

```diff
+XHR_REQUESTS = {};
+
 function XMLHttpRequest() {
-  // 빈 구현
+  this.handle = Object.keys(XHR_REQUESTS).length;
+  XHR_REQUESTS[this.handle] = this;                      // 전역 객체 저장
 }

 XMLHttpRequest.prototype.open = function (method, url, is_async) {
-  if (is_async) throw Error("Asynchronous XHR is not supported");
+  this.is_async = is_async;                              // 비동기 모드 저장
   this.method = method;
   this.url = url;
 };

 XMLHttpRequest.prototype.send = function (body) {
-  this.responseText = call_python("XMLHttpRequest_send", this.method, this.url, body);
+  this.responseText = call_python("XMLHttpRequest_send",
+    this.method, this.url, body, this.is_async, this.handle);
 };
+
+function __runXHROnload(body, handle) {
+  var obj = XHR_REQUESTS[handle];                        // 핸들로 XHR 객체 찾기
+  var evt = new Event("load");
+  obj.responseText = body;
+  if (obj.onload) obj.onload(evt);                       // onload 콜백 호출
+}
```

**browser.py**:

```diff
+XHR_ONLOAD_JS = "__runXHROnload(dukpy.out, dukpy.handle)"
+
 class JSContext:
-    def XMLHttpRequest_send(self, method, url, body):
+    def XMLHttpRequest_send(
+        self, method, url, body, isasync, handle):
         full_url = self.tab.url.resolve(url)
         if not self.tab.allowed_request(full_url):
             raise Exception("Cross-origin XHR blocked by CSP")
-        headers, out = full_url.request(self.tab.url, body)
         if full_url.origin() != self.tab.url.origin():
-            raise Exception("Cross-origin XHR request not allowed")
-        return out
+            raise Exception(
+                "Cross-origin XHR request not allowed")
+
+        def run_load():
+            headers, response = full_url.request(self.tab.url, body)
+            task = Task(self.dispatch_xhr_onload, response, handle)
+            self.tab.task_runner.schedule_task(task)      # 완료 후 태스크 큐에 추가
+            if not isasync:
+                return response
+
+        if not isasync:
+            return run_load()                              # 동기 모드: 즉시 실행
+        else:
+            threading.Thread(target=run_load).start()      # 비동기: 새 스레드에서 실행
```

**동작 흐름** (비동기 모드):

1. JS에서 `xhr.send()` 호출
2. 새 스레드에서 HTTP 요청 실행
3. 응답 받으면 `dispatch_xhr_onload` 태스크를 큐에 추가
4. 탭의 메인 스레드가 태스크 실행
5. `__runXHROnload`이 JS의 `onload` 콜백 호출

#### requestAnimationFrame 구현

**runtime.js**:

```diff
+RAF_LISTENERS = [];
+
+function requestAnimationFrame(fn) {
+  RAF_LISTENERS.push(fn);                                // 콜백 등록
+  call_python("requestAnimationFrame");
+}
+
+function __runRAFHandlers() {
+  var handlers_copy = RAF_LISTENERS;
+  RAF_LISTENERS = [];                                     // 새로운 빈 배열로 교체
+  for (var i = 0; i < handlers_copy.length; i++) {
+    handlers_copy[i]();                                   // 모든 콜백 실행
+  }
+}
```

**browser.py**:

```diff
 class JSContext:
     def __init__(self, tab):
+        self.interp.export_function("requestAnimationFrame",
+            self.requestAnimationFrame)
+
+    def requestAnimationFrame(self):
+        self.tab.browser.set_needs_animation_frame(self.tab)  # 브라우저에 애니메이션 프레임 요청
```

### 3. 렌더링 파이프라인 개선 (Commit 패턴)

**목적**: 브라우저 스레드(UI 스레드)와 탭의 메인 스레드를 분리하여 렌더링과 로직 실행을 병렬화

**브라우저의 Commit**:

```python
# 탭 스레드에서 작업 (로컬 버퍼)
self.display_list = []
paint_tree(self.document, self.display_list)  # 렌더링 명령 생성

# commit으로 확정 → 브라우저에 반영
self.browser.commit(self, commit_data)
```

**핵심 개념**:

- **작업 단계**: 각자의 공간에서 자유롭게 작업 (탭 스레드의 로컬 버퍼)
- **확정 단계**: 완료된 결과를 공유 공간에 반영 (브라우저의 상태)
- **원자성**: commit은 한 번에 모든 변경사항을 반영 (부분 반영 없음)

#### 문제 상황: Commit이 필요한 이유

**시나리오 1: 직접 공유 상태 수정 (Commit 없이)**

```python
# 탭 스레드
def render():
    browser.display_list = []           # ❌ 브라우저가 읽는 도중 초기화
    paint_tree(document, browser.display_list)  # ❌ 브라우저가 불완전한 리스트 읽음

# 브라우저 스레드
def raster():
    for cmd in browser.display_list:   # ❌ 탭이 수정 중인 리스트
        cmd.execute(canvas)             # 크래시 또는 화면 깨짐
```

**문제점**:

1. **데이터 경합**: 두 스레드가 동시에 같은 데이터 접근
2. **불완전한 상태 노출**: 렌더링 중간 상태가 화면에 표시됨
3. **락 필요**: 모든 접근마다 락 획득 → 성능 저하

**시나리오 2: Commit 패턴 사용**

```python
# 탭 스레드
def render():
    local_list = []                     # ✅ 로컬 버퍼에서 작업
    paint_tree(document, local_list)   # ✅ 브라우저와 독립적
    commit(local_list)                  # ✅ 완료 후 한 번에 전달

# 브라우저 스레드
def raster():
    for cmd in browser.display_list:   # ✅ 안정적인 리스트
        cmd.execute(canvas)             # 항상 완성된 프레임
```

**장점**:

1. **격리**: 각 스레드가 독립적으로 작업
2. **완결성**: 항상 완성된 프레임만 표시
3. **성능**: commit 시에만 짧은 락

#### Commit 패턴의 핵심 구조

**1. CommitData - 전달 패킷**

```python
class CommitData:
    """탭에서 브라우저로 전달할 '스냅샷'"""
    def __init__(self, url, scroll, height, display_list):
        self.url = url                    # 현재 URL
        self.scroll = scroll              # 스크롤 위치
        self.height = height              # 문서 전체 높이
        self.display_list = display_list  # 렌더링 명령 리스트
```

**CommitData의 역할**:

- 탭의 현재 상태를 **스냅샷**으로 캡처
- 여러 데이터를 **하나의 패킷**으로 묶어서 전달
- **원자성** 보장: 모든 데이터가 함께 업데이트되거나 전혀 안 됨

**비유**: 우편 소포

```
탭 스레드 (발신자)
  ├─ URL, scroll, height, display_list를 상자에 담기
  └─ commit(상자) → 우체국에 맡김

브라우저 스레드 (수신자)
  ├─ 상자 도착 시 한 번에 개봉
  └─ 모든 내용물을 꺼내서 적용
```

**2. 탭의 역할 - Producer (생산자)**

탭 스레드는 렌더링 결과를 **생산**하는 역할입니다.

```python
class Tab:
    def run_animation_frame(self, scroll):
        """애니메이션 프레임 실행 - 렌더링 + Commit"""

        # 1단계: 브라우저에서 받은 스크롤 값 동기화
        if not self.scroll_changed_in_tab:
            self.scroll = scroll  # 브라우저의 스크롤 사용

        # 2단계: RAF 콜백 실행 (JavaScript)
        self.js.interp.evaljs("__runRAFHandlers()")

        # 3단계: 렌더링 수행 (로컬 버퍼에)
        self.render()  # display_list 생성

        # 4단계: CommitData 패킷 생성
        scroll = None
        if self.scroll_changed_in_tab:
            scroll = self.scroll  # 탭에서 변경했으면 전달

        document_height = math.ceil(self.document.height + 2*VSTEP)
        commit_data = CommitData(
            self.url,
            scroll,
            document_height,
            self.display_list  # 완성된 렌더링 명령
        )

        # 5단계: 참조 해제 (중요!)
        self.display_list = None  # 이제 브라우저 소유

        # 6단계: Commit 실행
        self.browser.commit(self, commit_data)

        # 7단계: 플래그 리셋
        self.scroll_changed_in_tab = False
```

**탭의 작업 흐름**:

```
[RAF 콜백] → [render()] → [패킷 생성] → [commit()]
   ↓            ↓            ↓              ↓
 JS 실행    display_list  CommitData    브라우저에 전달
            생성          포장
```

**3. 브라우저의 역할 - Consumer (소비자)**

브라우저 스레드는 commit된 결과를 **소비**하여 화면에 표시합니다.

```python
class Browser:
    def __init__(self):
        self.lock = threading.Lock()
        # 브라우저가 관리하는 상태 (읽기 전용 버퍼)
        self.active_tab_url = None
        self.active_tab_scroll = 0
        self.active_tab_height = 0
        self.active_tab_display_list = None  # 탭에서 commit된 리스트

    def commit(self, tab, data):
        """탭의 commit을 받아서 브라우저 상태 업데이트"""
        self.lock.acquire(blocking=True)  # 짧은 락 획득

        # 현재 활성 탭인지 확인
        if tab == self.active_tab:
            # CommitData에서 모든 데이터 추출
            self.active_tab_url = data.url
            if data.scroll != None:
                self.active_tab_scroll = data.scroll
            self.active_tab_height = data.height
            if data.display_list:
                self.active_tab_display_list = data.display_list  # 포인터 교환

            # 애니메이션 타이머 리셋
            self.animation_timer = None

            # 화면 갱신 요청
            self.set_needs_raster_and_draw()

        self.lock.release()  # 즉시 락 해제

    def raster_and_draw(self):
        """래스터화 + 화면 그리기"""
        self.lock.acquire(blocking=True)

        if not self.needs_raster_and_draw:
            self.lock.release()
            return

        # 래스터화: display_list → Surface (픽셀)
        self.raster_tab()

        # 그리기: Surface → SDL 윈도우
        self.draw()

        self.needs_raster_and_draw = False
        self.lock.release()

    def raster_tab(self):
        """display_list를 실행하여 Surface에 그리기"""
        canvas = self.tab_surface.getCanvas()
        canvas.clear(skia.ColorWHITE)

        # commit된 display_list 사용
        for cmd in self.active_tab_display_list:
            cmd.execute(canvas)
```

**브라우저의 작업 흐름**:

```
[commit() 받음] → [상태 업데이트] → [raster_and_draw()]
      ↓               ↓                    ↓
  CommitData    active_tab_*        display_list → 화면
  패킷 수신      변수 업데이트           실행
```

#### 전체 Commit 플로우 (상세 타임라인)

```
=== 프레임 N ===

시간 0ms: 브라우저 스레드 (메인 루프)
  ├─ schedule_animation_frame() 호출
  ├─ needs_animation_frame = True 확인
  └─ Timer(33ms) 시작

시간 1ms ~ 33ms: (대기 중)
  브라우저: SDL 이벤트 처리, 이전 프레임 표시
  탭: 이전 태스크 처리

시간 33ms: 타이머 스레드
  ├─ Timer 콜백 실행
  ├─ 브라우저 lock 획득 → scroll 값 캡처
  ├─ Task(run_animation_frame, scroll) 생성
  └─ 탭의 TaskRunner 큐에 추가

시간 34ms: 탭 스레드
  ├─ TaskRunner가 태스크 꺼냄
  ├─ run_animation_frame(scroll) 실행 시작
  │  ├─ 1. scroll 동기화 (34ms)
  │  ├─ 2. RAF 콜백 실행 (34-40ms)
  │  ├─ 3. render() 실행 (40-70ms)
  │  │     ├─ style() - CSS 적용
  │  │     ├─ layout() - 위치 계산
  │  │     └─ paint() - display_list 생성
  │  ├─ 4. CommitData 패킷 생성 (70ms)
  │  ├─ 5. display_list = None (70ms)
  │  └─ 6. commit() 호출 (70ms)

시간 70ms: 탭 → 브라우저 (commit)
  탭:
    └─ browser.commit(self, commit_data) 호출
  브라우저:
    ├─ lock 획득 (즉시 또는 짧은 대기)
    ├─ active_tab_display_list = data.display_list  (포인터 복사)
    ├─ active_tab_scroll = data.scroll
    ├─ active_tab_height = data.height
    ├─ needs_raster_and_draw = True
    └─ lock 해제
  소요 시간: ~0.01ms (매우 빠름!)

시간 71ms: 탭 스레드
  └─ run_animation_frame 완료, 다음 태스크 대기

시간 72ms: 브라우저 스레드 (메인 루프)
  ├─ raster_and_draw() 호출
  ├─ lock 획득
  ├─ needs_raster_and_draw = True 확인
  ├─ raster_tab():
  │     └─ for cmd in active_tab_display_list:
  │           cmd.execute(canvas)  (72-88ms)
  ├─ draw():
  │     └─ SDL_BlitSurface() → 화면 업데이트 (88-90ms)
  └─ lock 해제

시간 90ms: 프레임 N 완료!
  └─ 사용자는 34ms 이후 업데이트된 화면 확인

=== 프레임 N+1 시작 ===
```

#### Commit의 핵심 특징

**1. 원자성 (Atomicity)**

```python
# 모든 데이터가 함께 업데이트됨
def commit(self, tab, data):
    # URL만 업데이트되고 display_list는 안 되는 상황 없음
    self.active_tab_url = data.url
    self.active_tab_scroll = data.scroll
    self.active_tab_height = data.height
    self.active_tab_display_list = data.display_list  # 모두 함께!
```

**2. 비차단 (Non-blocking)**

```python
# 나쁜 예: 탭이 렌더링 끝날 때까지 브라우저 대기
def bad_approach():
    tab.render()  # 30ms 동안 블록
    browser.draw()

# 좋은 예: 탭이 비동기로 렌더링, 브라우저는 계속 동작
def good_approach():
    # 탭 스레드
    task = Task(tab.render)
    tab.task_runner.schedule(task)  # 즉시 반환

    # 브라우저 스레드
    browser.draw()  # 이전 프레임 계속 표시
```

**3. 단방향 흐름**

```
탭 → 브라우저 (commit만 가능)
브라우저 ↛ 탭 (직접 수정 불가)

예외: scroll은 양방향 동기화 필요
  브라우저 → 탭: 사용자 스크롤 입력
  탭 → 브라우저: 페이지 로드 시 스크롤 리셋
```

#### 실제 사용 예시

**예시 1: 사용자가 버튼 클릭**

```
1. 브라우저 스레드: 마우스 클릭 이벤트
   ↓
2. handle_click(e) → Task(tab.click, x, y) 생성
   ↓
3. 탭의 TaskRunner에 태스크 추가 (브라우저는 즉시 반환)
   ↓
4. 탭 스레드: 태스크 실행
   - click() 처리
   - JavaScript 이벤트 핸들러 실행
   - element.innerHTML = "..." (DOM 변경)
   ↓
5. innerHTML_set() → set_needs_render()
   ↓
6. set_needs_animation_frame() → 브라우저에 알림
   ↓
7. 브라우저: Timer(33ms) 시작
   ↓
8. 33ms 후: run_animation_frame 태스크 추가
   ↓
9. 탭: render() → display_list 생성 → commit()
   ↓
10. 브라우저: commit() 받아서 active_tab_display_list 업데이트
   ↓
11. 브라우저: raster_and_draw() → 화면 갱신
```

**시간 흐름**:

```
0ms:   클릭 이벤트
1ms:   Task 추가 (브라우저 즉시 반환)
2ms:   탭 스레드에서 click() 처리
5ms:   innerHTML 변경 → set_needs_render()
6ms:   애니메이션 프레임 예약
39ms:  run_animation_frame 실행
40-70ms: render() (30ms)
70ms:  commit() (0.01ms)
72-90ms: raster_and_draw() (18ms)
```

**결과**: 클릭 후 ~90ms에 화면 업데이트 (30 FPS 유지)

**예시 2: setTimeout으로 DOM 변경**

```javascript
// JavaScript
setTimeout(function () {
  document.querySelector("#box").innerHTML = "Updated!";
}, 1000);
```

```
0ms: setTimeout() 호출
  ↓ Python의 threading.Timer(1.0초) 시작

1000ms: Timer 콜백 실행 (새 스레드)
  ↓ Task(dispatch_settimeout) 추가

1001ms: 탭 스레드에서 태스크 실행
  ↓ __runSetTimeout() → JS 콜백 실행
  ↓ innerHTML = 'Updated!'
  ↓ innerHTML_set() → set_needs_render()

1002ms: set_needs_animation_frame()
  ↓ 브라우저에 알림

1035ms: run_animation_frame 실행 (33ms 후)
  ↓ render()
  ↓ commit()

1065ms: 브라우저가 화면 갱신
```

**핵심**: setTimeout 콜백도 RAF를 통해 렌더링 → 항상 완성된 프레임만 표시

#### Commit 패턴의 장점 요약

| 측면              | 직접 수정 (Commit 없음)   | Commit 패턴            |
| ----------------- | ------------------------- | ---------------------- |
| **데이터 일관성** | 부분 업데이트 가능 (버그) | 원자적 업데이트 (안전) |
| **락 시간**       | 렌더링 전체 (~30ms)       | commit만 (~0.01ms)     |
| **UI 응답성**     | 렌더링 중 블록            | 항상 응답              |
| **프레임 드롭**   | 렌더링 느리면 화면 멈춤   | 이전 프레임 유지       |
| **복잡도**        | 낮음                      | 중간 (CommitData 필요) |

#### 실제 브라우저와의 비교

**Chromium의 Compositor Commit**:

```
Renderer Process (탭)
  ├─ Main Thread: Layout, Paint → Layer List 생성
  └─ Compositor Thread: Layer List → Tiles 생성
      └─ IPC로 Browser Process에 commit
          └─ GPU Process: Tiles → 화면

특징:
- 프로세스 간 통신 (IPC) → 데이터 복사 필요
- 메모리 오버헤드 큼, 보안 강화
```

**우리 브라우저의 Commit**:

```
Tab Thread (탭)
  ├─ render(): display_list 생성
  └─ commit(CommitData) → Browser Thread
      └─ raster_and_draw(): display_list → 화면

특징:
- 같은 프로세스 내 스레드 간 통신 → 포인터 교환만
- 메모리 효율적, 속도 빠름
- 탭 크래시 시 브라우저도 영향 (단점)
```

### 4. 이벤트 처리의 비동기화

**변경 전**: 브라우저 스레드에서 직접 탭의 메서드 호출

```python
# 동기적 처리
self.active_tab.click(e.x, tab_y)
self.active_tab.keypress(char)
```

**변경 후**: 태스크로 변환하여 탭의 큐에 추가

```diff
     def handle_click(self, e):
+        self.lock.acquire(blocking=True)
         if e.y < self.chrome.bottom:
             self.focus = None
             self.chrome.click(e.x, e.y)
-            self.raster_chrome()
+            self.set_needs_raster_and_draw()
         else:
-            self.focus = "content"
+            if self.focus != "content":
+                self.focus = "content"
+                self.chrome.focus = None
+                self.set_needs_raster_and_draw()
             self.chrome.blur()
-            url = self.active_tab.url
             tab_y = e.y - self.chrome.bottom
-            self.active_tab.click(e.x, tab_y)
-            if self.active_tab.url != url:
-                self.raster_chrome()
-            self.raster_tab()
-        self.draw()
+            task = Task(self.active_tab.click, e.x, tab_y)
+            self.active_tab.task_runner.schedule_task(task)  # 태스크 큐에 추가
+        self.lock.release()
```

**장점**:

- 브라우저 스레드가 탭의 처리를 기다리지 않음 (non-blocking)
- 탭의 상태를 탭 스레드에서만 변경 (thread-safety)

### 5. 페이지 로딩의 비동기화

```diff
     def load(self, url, payload=None):
         headers, body = url.request(self.url, payload)
         self.history.append(url)
         self.url = url
+        self.scroll = 0
+        self.scroll_changed_in_tab = True

         self.nodes = HTMLParser(body).parse()

+        if self.js: self.js.discarded = True              # 이전 JS 컨텍스트 폐기
         self.js = JSContext(self)
         scripts = [node.attributes["src"] for node
                    in tree_to_list(self.nodes, [])
@@ -1026,7 +1190,8 @@ class Tab:
                 headers, body = script_url.request(url)
             except:
                 continue
-            self.js.run(script, body)
+            task = Task(self.js.run, script_url, body)
+            self.task_runner.schedule_task(task)          # 스크립트 실행을 태스크로 예약
```

**핵심 변화**:

- `self.js.discarded`: 페이지 이동 시 이전 페이지의 setTimeout, XHR 콜백이 실행되지 않도록 방지
- 스크립트 실행을 태스크로 예약하여 순차적으로 실행

### 6. 성능 측정 시스템 (Chrome Tracing)

```diff
+class MeasureTime:
+    def __init__(self):
+        self.lock = threading.Lock()
+        self.file = open("browser.trace", "w")
+        self.file.write('{"traceEvents": [')             # Chrome tracing 형식
+        # ... 메타데이터 작성
+
+    def time(self, name):
+        """측정 시작 (Begin)"""
+        ts = time.time() * 1000000                        # 마이크로초 단위
+        tid = threading.get_ident()                       # 스레드 ID
+        self.lock.acquire(blocking=True)
+        self.file.write(
+            ', { "ph": "B", "cat": "_",' +                # "B" = Begin
+            '"name": "' + name + '",' +
+            '"ts": ' + str(ts) + ',' +
+            '"pid": 1, "tid": ' + str(tid) + '}')
+        self.file.flush()
+        self.lock.release()
+
+    def stop(self, name):
+        """측정 종료 (End)"""
+        # ... "ph": "E" (End) 이벤트 작성
+
+    def finish(self):
+        """스레드 이름 메타데이터 작성 후 파일 닫기"""
+        self.lock.acquire(blocking=True)
+        for thread in threading.enumerate():
+            self.file.write(
+                ', { "ph": "M", "name": "thread_name",' +
+                '"pid": 1, "tid": ' + str(thread.ident) + ',' +
+                '"args": { "name": "' + thread.name + '"}}')
+        self.file.write(']}')
+        self.file.close()
+        self.lock.release()
```

**사용법**:

1. `browser.measure.time('render')` - 측정 시작
2. 코드 실행
3. `browser.measure.stop('render')` - 측정 종료
4. Chrome의 `chrome://tracing`에서 `browser.trace` 파일 열기

### 7. 메인 루프 변경

```diff
 def mainloop(browser):
     event = sdl2.SDL_Event()
     while True:
-        while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:
+        if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:  # while → if로 변경
             if event.type == sdl2.SDL_QUIT:
                 browser.handle_quit()
                 sdl2.SDL_Quit()
@@ -1418,6 +1729,8 @@ def mainloop(browser):
                     browser.handle_down()
             elif event.type == sdl2.SDL_TEXTINPUT:
                 browser.handle_key(event.text.text.decode('utf8'))
+        browser.raster_and_draw()                         # 매 루프마다 실행
+        browser.schedule_animation_frame()
```

**변경 이유**:

- `while` → `if`: 이벤트를 하나만 처리하고 바로 렌더링/애니메이션 스케줄링 수행
- 매 루프마다 `raster_and_draw()`와 `schedule_animation_frame()` 호출
- 더 일정한 프레임 레이트 유지

## 아키텍처 요약

### 스레드 구조

```
브라우저 스레드 (메인 루프)
├── SDL 이벤트 처리
├── raster_and_draw() - 화면 그리기
└── schedule_animation_frame() - 애니메이션 프레임 예약

탭 메인 스레드 (각 탭마다)
├── Task 큐에서 태스크 꺼내기
├── JavaScript 실행
├── 렌더링 (style, layout, paint)
└── commit() - 브라우저에 결과 전달

타이머 스레드들
├── setTimeout 타이머
├── animation_timer (33ms)
└── XHR 비동기 요청 스레드
```

### 데이터 흐름 (렌더링 예시)

```
1. JS에서 DOM 변경 (innerHTML 등)
   ↓
2. set_needs_render() 호출
   ↓
3. set_needs_animation_frame(tab) → 브라우저에 알림
   ↓
4. 브라우저: schedule_animation_frame() → 33ms 타이머 시작
   ↓
5. 33ms 후: run_animation_frame 태스크를 탭 큐에 추가
   ↓
6. 탭 스레드: 태스크 실행
   - RAF 콜백 실행
   - render() 수행
   - commit(display_list) → 브라우저에 전달
   ↓
7. 브라우저 스레드: commit() 받아서
   - active_tab_display_list 업데이트
   - set_needs_raster_and_draw() 플래그 설정
   ↓
8. 메인 루프: raster_and_draw() 실행
   - display_list로 Surface에 그리기
   - SDL로 화면 업데이트
```

### 동기화 메커니즘

- **Browser.lock**: 브라우저 상태(스크롤, display_list 등) 보호
- **TaskRunner.condition**: 태스크 큐 보호 + 스레드 대기/깨우기
- **MeasureTime.lock**: 추적 파일 쓰기 동기화

## 핵심 개념

### 1. 더티 플래그 패턴

- `needs_render`: 렌더링 필요 여부
- `needs_raster_and_draw`: 래스터화/그리기 필요 여부
- `needs_animation_frame`: 애니메이션 프레임 예약 필요 여부
  → 불필요한 재계산 방지

### 2. 이중 버퍼링 (Commit 패턴)

#### 문제 상황

멀티스레딩 환경에서 두 개의 스레드가 동시에 같은 데이터를 읽고 쓰면 **데이터 경합(race condition)**이 발생합니다.

**예시: 이중 버퍼링이 없다면?**

```python
# 탭 스레드에서 렌더링 중
tab.display_list = []  # 초기화
paint_tree(tab.document, tab.display_list)  # 명령어 추가 중...

# 동시에 브라우저 스레드에서 그리기
for cmd in tab.display_list:  # ❌ 불완전한 리스트를 읽음!
    cmd.execute(canvas)       # 화면 깜빡임 또는 크래시 발생
```

**문제점**:

1. **데이터 불일치**: 브라우저가 반쯤 완성된 display_list를 읽어서 화면이 깨짐
2. **락 경합**: 매번 접근할 때마다 락을 걸면 성능 저하
3. **데드락**: 탭이 렌더링 중 브라우저가 대기 → UI 응답성 저하

#### 해결책: 이중 버퍼링

**핵심 아이디어**: 각 스레드가 **독립적인 버퍼**를 사용하고, **완료 시점**에만 포인터를 교환

```python
# Tab 클래스 (탭 스레드가 사용)
class Tab:
    def __init__(self):
        self.display_list = []           # 탭 전용 버퍼 (쓰기용)

    def render(self):
        # 탭 스레드에서 자유롭게 작업
        self.display_list = []           # 새로운 리스트 생성
        paint_tree(self.document, self.display_list)  # 명령어 추가

    def run_animation_frame(self, scroll):
        self.render()                    # 렌더링 수행

        # 완료 후 commit
        commit_data = CommitData(
            self.url,
            self.scroll,
            self.document.height,
            self.display_list            # 완성된 리스트 전달
        )
        self.display_list = None         # 참조 해제 (중요!)
        self.browser.commit(self, commit_data)

# Browser 클래스 (브라우저 스레드가 사용)
class Browser:
    def __init__(self):
        self.lock = threading.Lock()
        self.active_tab_display_list = None  # 브라우저 전용 버퍼 (읽기용)

    def commit(self, tab, data):
        """탭에서 완성된 display_list를 받아서 교환"""
        self.lock.acquire(blocking=True)     # 짧은 시간만 락 획득
        if tab == self.active_tab:
            self.active_tab_display_list = data.display_list  # 포인터 교환
            self.set_needs_raster_and_draw()
        self.lock.release()                  # 즉시 락 해제

    def raster_and_draw(self):
        self.lock.acquire(blocking=True)
        if not self.needs_raster_and_draw:
            self.lock.release()
            return
        # 브라우저 스레드에서 안전하게 읽기
        self.raster_tab()                    # active_tab_display_list 사용
        self.draw()
        self.lock.release()

    def raster_tab(self):
        canvas = self.tab_surface.getCanvas()
        canvas.clear(skia.ColorWHITE)
        # 브라우저 전용 버퍼에서 읽기
        for cmd in self.active_tab_display_list:
            cmd.execute(canvas)
```

#### 동작 흐름 (타임라인)

```
시간 →

탭 스레드:
  |--[렌더링 시작]--|
  | display_list=[] |
  | paint_tree()    |
  |--[렌더링 완료]--|
                    |--[commit()]--|  (락 획득, 포인터 교환, 락 해제)
                                    |--[다음 렌더링 시작]--|

브라우저 스레드:
  |--[이전 프레임 그리기]--|
                          |--[commit 대기]--|  (락 획득 대기)
                                            |--[새 프레임 그리기]--|
```

**핵심 포인트**:

- **탭 스레드**: `display_list`에 **쓰기** (락 없이 자유롭게)
- **브라우저 스레드**: `active_tab_display_list`에서 **읽기** (락 없이 자유롭게)
- **commit 시점**: 짧은 락으로 **포인터만 교환** (10μs 미만)

#### 메모리 관리

```python
# 1. 탭에서 새 display_list 생성
display_list_A = []
paint_tree(document, display_list_A)

# 2. commit 시 브라우저에 전달
commit_data = CommitData(..., display_list_A)
self.display_list = None  # 탭의 참조 해제

# 3. 브라우저가 포인터 저장
self.active_tab_display_list = display_list_A  # 참조 카운트 +1

# 4. 다음 프레임에서 새 리스트 생성
display_list_B = []  # 새로운 객체
paint_tree(document, display_list_B)

# 5. commit 시 교환
self.active_tab_display_list = display_list_B  # display_list_A 참조 카운트 -1
# display_list_A는 가비지 컬렉션됨
```

**왜 `self.display_list = None`이 중요한가?**

- 탭이 참조를 유지하면 다음 렌더링 시 **같은 리스트를 수정**할 위험
- 브라우저가 읽는 도중 탭이 수정하면 **데이터 경합** 발생
- 참조 해제로 "이 리스트는 브라우저 소유"를 명확히 함

#### 이중 버퍼링의 장점

**1. 락 경합 최소화**

```python
# 나쁜 예: 매번 락 획득
def render():
    self.lock.acquire()
    self.display_list = []
    paint_tree(self.document, self.display_list)  # 오래 걸림
    self.lock.release()  # 다른 스레드가 오래 대기

# 좋은 예: commit 시에만 락
def render():
    display_list = []  # 로컬 변수 (락 불필요)
    paint_tree(self.document, display_list)
    self.commit(display_list)  # 짧은 락 (10μs)
```

**2. 프레임 드롭 방지**

- 탭의 렌더링이 느려도 브라우저는 **이전 프레임**을 계속 표시
- 렌더링이 완료되면 **새 프레임으로 교체**
- 화면 깜빡임이나 티어링(tearing) 없음

**3. 스레드 안전성**

```python
# 각 스레드가 독립적인 데이터 구조 사용
# 탭 스레드
tab.display_list          # 쓰기 전용
tab.document              # 쓰기 전용
tab.nodes                 # 쓰기 전용

# 브라우저 스레드
browser.active_tab_display_list  # 읽기 전용
browser.active_tab_scroll        # 읽기 전용
browser.active_tab_height        # 읽기 전용
```

#### 성능 측정 예시

```python
# browser.trace에서 확인 가능
Browser Thread:  [이벤트][──raster_and_draw──][이벤트][──raster_and_draw──]
                         (16ms)                       (16ms)

Tab Thread:      [────────render()────────][commit][────render()────]
                         (30ms)            (0.01ms)    (25ms)
```

**관찰 결과**:

- render()가 오래 걸려도 (30ms) commit은 매우 빠름 (0.01ms)
- 브라우저는 render() 완료를 기다리지 않고 계속 동작
- 60 FPS 목표 시 16ms마다 그리기 → 탭이 느려도 UI는 부드러움

#### 스크롤 동기화 (추가 복잡성)

```python
# 문제: 스크롤은 양방향 동기화 필요
# - 브라우저: 사용자 스크롤 입력 받음
# - 탭: 페이지 로드 시 스크롤 초기화

class Tab:
    def run_animation_frame(self, scroll):
        if not self.scroll_changed_in_tab:
            self.scroll = scroll  # 브라우저 → 탭
        # ...
        scroll = None
        if self.scroll_changed_in_tab:
            scroll = self.scroll  # 탭 → 브라우저 (우선순위 높음)
        commit_data = CommitData(..., scroll, ...)

class Browser:
    def commit(self, tab, data):
        if data.scroll != None:
            self.active_tab_scroll = data.scroll  # 탭의 값 우선
```

**규칙**:

- 탭에서 `scroll_changed_in_tab = True`이면 탭의 값이 우선
- 그렇지 않으면 브라우저의 값 사용
- commit 시 탭의 스크롤을 전달하면 브라우저가 업데이트

#### 요약

| 측면             | 단일 버퍼 (이전)    | 이중 버퍼 (현재)       |
| ---------------- | ------------------- | ---------------------- |
| **데이터 경합**  | 있음 (크래시 위험)  | 없음 (안전)            |
| **락 획득 시간** | 렌더링 전체 (~30ms) | commit만 (~0.01ms)     |
| **UI 응답성**    | 렌더링 중 블록      | 항상 응답              |
| **화면 품질**    | 깜빡임, 티어링      | 부드러움               |
| **메모리**       | 적음                | 약간 많음 (리스트 2개) |

**결론**: 약간의 메모리 사용(리스트 2개)으로 **안전성**, **성능**, **응답성**을 크게 개선

### 3. 핸들 기반 객체 관리

- `node_to_handle`, `handle_to_node`: DOM 노드
- `SET_TIMEOUT_REQUESTS`: setTimeout 콜백
- `XHR_REQUESTS`: XMLHttpRequest 객체
  → Python-JavaScript 간 객체 참조 유지

## 주의사항

### 메모리 누수 방지

```python
def run(self):
    self.task_code(*self.args)
    self.task_code = None    # 순환 참조 방지
    self.args = None
```

### 폐기된 컨텍스트 처리

```python
def dispatch_xhr_onload(self, out, handle):
    if self.discarded: return  # 페이지 이동 후 콜백 무시
    # ...
```

### 스크롤 동기화

- `scroll_changed_in_tab`: 탭에서 변경된 스크롤 우선
- 브라우저와 탭 간 스크롤 값 충돌 해결

## 성능 최적화

1. **비동기 스크립트 로딩**: 네트워크 요청이 UI를 블록하지 않음
2. **RAF 스케줄링**: 30 FPS로 제한하여 불필요한 렌더링 방지
3. **더티 플래그**: 변경된 경우에만 재렌더링
4. **태스크 큐**: JavaScript 실행과 렌더링을 순차적으로 처리하여 경합 방지
