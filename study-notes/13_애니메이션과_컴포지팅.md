# 애니메이션과 컴포지팅

## 개요

이번 변경에서는 **CSS 애니메이션**, **GPU 가속 컴포지팅**, **transform** 기능을 구현하여 부드러운 시각 효과와 성능 최적화를 달성했습니다.

## 주요 변경사항

### 1. GPU 가속과 OpenGL 도입

**목적**: CPU 기반 래스터화에서 GPU 가속 렌더링으로 전환하여 성능 향상

#### OpenGL 컨텍스트 초기화

```diff
 class Browser:
     def __init__(self):
         self.sdl_window = sdl2.SDL_CreateWindow(b"Browser",
             sdl2.SDL_WINDOWPOS_CENTERED, sdl2.SDL_WINDOWPOS_CENTERED,
-            WIDTH, HEIGHT, sdl2.SDL_WINDOW_SHOWN)
+            WIDTH, HEIGHT, sdl2.SDL_WINDOW_SHOWN | sdl2.SDL_WINDOW_OPENGL)
+
+        # OpenGL 컨텍스트 생성
+        self.gl_context = sdl2.SDL_GL_CreateContext(self.sdl_window)
+        print(("OpenGL initialized: vendor={}," + \
+            "renderer={}").format(
+            OpenGL.GL.glGetString(OpenGL.GL.GL_VENDOR),
+            OpenGL.GL.glGetString(OpenGL.GL.GL_RENDERER)))
+
+        # Skia GPU 컨텍스트
+        self.skia_context = skia.GrDirectContext.MakeGL()
```

**변경 전 (CPU 래스터화)**:

```python
# CPU에서 픽셀 직접 계산
self.root_surface = skia.Surface.MakeRaster(
    skia.ImageInfo.Make(WIDTH, HEIGHT, ...))
```

**변경 후 (GPU 가속)**:

```python
# GPU 백엔드 사용
self.root_surface = skia.Surface.MakeFromBackendRenderTarget(
    self.skia_context,
    skia.GrBackendRenderTarget(
        WIDTH, HEIGHT, 0, 0,
        skia.GrGLFramebufferInfo(0, OpenGL.GL.GL_RGBA8)),
    skia.kBottomLeft_GrSurfaceOrigin,
    skia.kRGBA_8888_ColorType,
    skia.ColorSpace.MakeSRGB())
```

**장점**:

- **속도**: GPU가 병렬로 픽셀 계산 (CPU보다 10-100배 빠름)
- **품질**: 하드웨어 안티앨리어싱, 필터링
- **효율성**: 메모리 대역폭 절약

### 2. CSS 애니메이션 시스템

#### transition 속성 파싱

```python
def parse_transition(value):
    """CSS transition 문자열 파싱"""
    properties = {}
    if not value: return properties

    # "opacity 1s, transform 0.5s" 형태 파싱
    for item in value.split(","):
        property, duration = item.split(" ", 1)
        # 초 단위 → 프레임 수로 변환 (30 FPS 기준)
        frames = int(float(duration[:-1]) / REFRESH_RATE_SEC)  # 0.033초
        properties[property] = frames

    return properties
```

**예시**:

```css
.box {
  opacity: 0.5;
  transition: opacity 1s;
}
```

→ `parse_transition("opacity 1s")` → `{"opacity": 30}` (1초 ÷ 0.033 = 30 프레임)

#### 스타일 변화 감지

```python
def diff_styles(old_style, new_style):
    """이전 스타일과 새 스타일 비교하여 애니메이션 필요 항목 찾기"""
    transitions = {}

    for property, num_frames in \
        parse_transition(new_style.get("transition")).items():
        # transition 속성으로 지정된 프로퍼티만 확인
        if property not in old_style: continue
        if property not in new_style: continue

        old_value = old_style[property]
        new_value = new_style[property]

        if old_value == new_value: continue  # 변화 없으면 스킵

        # (시작값, 끝값, 프레임 수) 튜플 저장
        transitions[property] = \
            (old_value, new_value, num_frames)

    return transitions
```

**동작 예시**:

```python
old_style = {"opacity": "1.0", "transition": "opacity 1s"}
new_style = {"opacity": "0.5", "transition": "opacity 1s"}

diff_styles(old_style, new_style)
# → {"opacity": ("1.0", "0.5", 30)}
```

#### NumericAnimation 클래스

```python
class NumericAnimation:
    def __init__(self, old_value, new_value, num_frames):
        self.old_value = float(old_value)  # 시작값
        self.new_value = float(new_value)  # 끝값
        self.num_frames = num_frames       # 총 프레임 수

        self.frame_count = 1  # 현재 프레임
        # 매 프레임마다 변화할 값
        total_change = self.new_value - self.old_value
        self.change_per_frame = total_change / num_frames

    def animate(self):
        """다음 프레임 값 계산"""
        self.frame_count += 1

        if self.frame_count >= self.num_frames:
            return None  # 애니메이션 완료

        # 선형 보간 (linear interpolation)
        current_value = self.old_value + \
            self.change_per_frame * self.frame_count

        return str(current_value)
```

**선형 보간 (Linear Interpolation)**:

```
프레임 0:  old_value = 1.0
프레임 1:  1.0 + (0.5 - 1.0) / 30 * 1 = 0.983
프레임 2:  1.0 + (0.5 - 1.0) / 30 * 2 = 0.967
...
프레임 30: 1.0 + (0.5 - 1.0) / 30 * 30 = 0.5
```

#### style() 함수에서 애니메이션 생성

```diff
-def style(node, rules):
+def style(node, rules, tab):
+    old_style = node.style  # 이전 스타일 저장
+
     # CSS 규칙 적용하여 새 스타일 계산
     node.style = {}
     for property, default_value in INHERITED_PROPERTIES.items():
         # ...

+    # 스타일 변화가 있고, transition이 정의되어 있으면 애니메이션 생성
+    if old_style:
+        transitions = diff_styles(old_style, node.style)
+        for property, (old_value, new_value, num_frames) \
+            in transitions.items():
+            if property == "opacity":  # 현재는 opacity만 지원
+                tab.set_needs_render()  # 렌더링 요청
+                animation = NumericAnimation(
+                    old_value, new_value, num_frames)
+                node.animations[property] = animation  # 애니메이션 저장
+                node.style[property] = animation.animate()  # 첫 프레임 적용
```

#### 매 프레임마다 애니메이션 업데이트

```python
def run_animation_frame(self, scroll):
    # ...RAF 콜백 실행...

    # 모든 노드의 애니메이션 업데이트
    for node in tree_to_list(self.nodes, []):
        for (property_name, animation) in node.animations.items():
            value = animation.animate()  # 다음 프레임 값 계산

            if value:  # 애니메이션이 아직 진행 중
                node.style[property_name] = value
                self.composited_updates.append(node)  # 부분 업데이트 목록에 추가
                self.set_needs_paint()  # 페인트만 필요
            # value가 None이면 애니메이션 완료
```

**전체 흐름**:

```
1. JavaScript: element.style = "opacity: 0.5; transition: opacity 1s"
   ↓
2. style_set() → set_needs_render()
   ↓
3. style() 함수 실행
   - diff_styles() → opacity 변화 감지
   - NumericAnimation 생성 → node.animations["opacity"]
   ↓
4. 매 프레임 (33ms마다):
   - run_animation_frame() 호출
   - animation.animate() → 0.983, 0.967, 0.950, ...
   - node.style["opacity"] 업데이트
   - composited_updates.append(node)
   ↓
5. 30 프레임 후:
   - animation.animate() → None (완료)
   - node.animations에서 제거됨
```

### 3. Transform 지원

#### transform 파싱

```python
def parse_transform(transform_str):
    """CSS transform 문자열 파싱 (현재는 translate만 지원)"""
    if transform_str.find('translate(') < 0:
        return None

    left_paren = transform_str.find('(')
    right_paren = transform_str.find(')')

    # "translate(10px, 20px)" → "10px, 20px"
    (x_px, y_px) = \
        transform_str[left_paren + 1:right_paren].split(",")

    # "10px" → 10.0
    return (float(x_px[:-2]), float(y_px[:-2]))
```

**예시**:

```python
parse_transform("translate(10px, 20px)")  # → (10.0, 20.0)
parse_transform("rotate(45deg)")          # → None (미지원)
```

#### Transform 클래스

```python
class Transform(VisualEffect):
    def __init__(self, translation, rect, node, children):
        super().__init__(rect, children, node)
        self.self_rect = rect
        self.translation = translation  # (x, y) 튜플

    def execute(self, canvas):
        """Canvas에 변환 적용"""
        if self.translation:
            (x, y) = self.translation
            canvas.save()          # 현재 상태 저장
            canvas.translate(x, y)  # 이동 변환

        for cmd in self.children:
            cmd.execute(canvas)    # 자식 명령 실행

        if self.translation:
            canvas.restore()       # 이전 상태 복원

    def map(self, rect):
        """로컬 좌표 → 부모 좌표 변환"""
        return map_translation(rect, self.translation)

    def unmap(self, rect):
        """부모 좌표 → 로컬 좌표 변환"""
        return map_translation(rect, self.translation, reversed=True)
```

#### 좌표 변환 유틸리티

```python
def map_translation(rect, translation, reversed=False):
    """사각형에 이동 변환 적용"""
    if not translation:
        return rect

    (x, y) = translation
    matrix = skia.Matrix()

    if reversed:
        matrix.setTranslate(-x, -y)  # 역변환
    else:
        matrix.setTranslate(x, y)

    return matrix.mapRect(rect)

def absolute_bounds_for_obj(obj):
    """레이아웃 객체의 절대 좌표 계산 (모든 transform 적용)"""
    rect = skia.Rect.MakeXYWH(
        obj.x, obj.y, obj.width, obj.height)

    # 부모 체인을 따라 올라가며 모든 transform 적용
    cur = obj.node
    while cur:
        rect = map_translation(rect,
            parse_transform(cur.style.get("transform", "")))
        cur = cur.parent

    return rect
```

**예시**:

```html
<div style="transform: translate(10px, 20px)">
  <div style="transform: translate(5px, 5px)">
    <span>Text</span>
    <!-- 최종 위치: (15px, 25px) -->
  </div>
</div>
```

```python
# span의 로컬 좌표: (0, 0, 50, 20)
# 부모 transform: translate(5px, 5px) → (5, 5, 55, 25)
# 조부모 transform: translate(10px, 20px) → (15, 25, 65, 45)
```

#### 클릭 감지에 transform 적용

```diff
     def click(self, x, y):
         self.render()
         self.focus = None
         y += self.scroll
+        loc_rect = skia.Rect.MakeXYWH(x, y, 1, 1)
+
         objs = [obj for obj in tree_to_list(self.document, [])
-            if obj.x <= x < obj.x + obj.width
-            and obj.y <= y < obj.y + obj.height]
+                if absolute_bounds_for_obj(obj).intersects(loc_rect)]
```

**변경 이유**:

- 이전: `obj.x, obj.y` (로컬 좌표) 사용 → transform 무시
- 이후: `absolute_bounds_for_obj()` (절대 좌표) 사용 → transform 적용

### 4. 컴포지팅 시스템

#### 문제 상황: 왜 컴포지팅이 필요한가?

**시나리오**: opacity가 0.5인 요소에 애니메이션 적용

**컴포지팅 없이**:

```python
# 매 프레임마다 전체 렌더링
def run_animation_frame():
    node.style["opacity"] = "0.51"  # 값 변경
    # style, layout, paint 모두 다시 실행
    style(self.nodes, ...)     # 30ms
    layout()                    # 20ms
    paint()                     # 15ms
    # 총 65ms → 15 FPS (느림!)
```

**컴포지팅 사용**:

```python
# 변경된 노드만 다시 그리기
def run_animation_frame():
    node.style["opacity"] = "0.51"
    # style, layout 스킵
    # composited layer만 다시 래스터화
    raster_layer(node.blend_op)  # 2ms
    # 총 2ms → 500 FPS (매우 빠름!)
```

#### CompositedLayer 클래스

```python
class CompositedLayer:
    """독립적으로 래스터화할 수 있는 레이어"""

    def __init__(self, skia_context, display_item):
        self.skia_context = skia_context
        self.surface = None  # GPU 텍스처
        self.display_items = [display_item]  # 이 레이어에 포함된 명령들

    def composited_bounds(self):
        """레이어의 로컬 좌표 범위"""
        rect = skia.Rect.MakeEmpty()
        for item in self.display_items:
            # 절대 좌표 → 로컬 좌표 변환
            rect.join(absolute_to_local(
                item, local_to_absolute(item, item.rect)))
        rect.outset(1, 1)  # 1px 여유
        return rect

    def can_merge(self, display_item):
        """이 레이어에 새 아이템을 병합할 수 있는지 확인"""
        # 같은 부모를 가진 아이템만 병합 가능
        return display_item.parent == self.display_items[0].parent

    def raster(self):
        """레이어를 GPU 텍스처에 래스터화"""
        bounds = self.composited_bounds()
        if bounds.isEmpty(): return

        irect = bounds.roundOut()  # 정수 좌표로 변환

        if not self.surface:
            # GPU 텍스처 생성 (한 번만)
            self.surface = skia.Surface.MakeRenderTarget(
                self.skia_context, skia.Budgeted.kNo,
                skia.ImageInfo.MakeN32Premul(
                    irect.width(), irect.height()))

        canvas = self.surface.getCanvas()
        canvas.clear(skia.ColorTRANSPARENT)

        # 레이어 좌표계로 변환
        canvas.save()
        canvas.translate(-bounds.left(), -bounds.top())

        # 모든 명령 실행
        for item in self.display_items:
            item.execute(canvas)

        canvas.restore()
```

#### 컴포지팅 단계 (composite)

```python
def composite(self):
    """display_list를 composited layers로 분할"""
    self.composited_layers = []

    # 1. 부모 포인터 설정 (트리 구조 복원)
    add_parent_pointers(self.active_tab_display_list)

    # 2. 트리를 평면 리스트로 변환
    all_commands = []
    for cmd in self.active_tab_display_list:
        all_commands = tree_to_list(cmd, all_commands)

    # 3. 컴포지팅이 필요 없는 명령만 필터링
    non_composited_commands = [cmd
        for cmd in all_commands
        # PaintCommand이거나, VisualEffect인데 compositing 불필요
        if isinstance(cmd, PaintCommand) or not cmd.needs_compositing
        # 부모가 없거나, 부모가 compositing 필요
        if not cmd.parent or cmd.parent.needs_compositing
    ]

    # 4. 레이어에 명령 할당
    for cmd in non_composited_commands:
        # 역순으로 탐색 (앞쪽 레이어가 뒤쪽 레이어를 가림)
        for layer in reversed(self.composited_layers):
            if layer.can_merge(cmd):
                # 같은 부모 → 병합 가능
                layer.add(cmd)
                break
            elif skia.Rect.Intersects(
                layer.absolute_bounds(),
                local_to_absolute(cmd, cmd.rect)):
                # 겹침 → 새 레이어 생성
                layer = CompositedLayer(self.skia_context, cmd)
                self.composited_layers.append(layer)
                break
        else:
            # 겹치는 레이어 없음 → 새 레이어 생성
            layer = CompositedLayer(self.skia_context, cmd)
            self.composited_layers.append(layer)
```

**예시**:

```
Display List:
  Transform (translate(10px, 0))
    Blend (opacity=0.5, needs_compositing=True)
      DrawText("Hello")
      DrawRect(...)
    DrawText("World")

Compositing 결과:
  Layer 0: DrawText("Hello"), DrawRect  (opacity=0.5 안)
  Layer 1: DrawText("World")             (opacity 밖)
```

#### DrawCompositedLayer

```python
class DrawCompositedLayer(PaintCommand):
    """컴포지트된 레이어를 그리는 명령"""

    def __init__(self, composited_layer):
        self.composited_layer = composited_layer
        super().__init__(
            self.composited_layer.composited_bounds())

    def execute(self, canvas):
        """GPU 텍스처를 화면에 복사"""
        layer = self.composited_layer
        bounds = layer.composited_bounds()

        # Surface를 Canvas에 그리기 (GPU 텍스처 복사)
        layer.surface.draw(canvas, bounds.left(), bounds.top())
```

#### paint_draw_list() - 효과 트리 재구성

```python
def paint_draw_list(self):
    """컴포지트된 레이어들을 VisualEffect 트리로 재구성"""
    new_effects = {}
    self.draw_list = []

    for composited_layer in self.composited_layers:
        # DrawCompositedLayer 생성
        current_effect = DrawCompositedLayer(composited_layer)

        if not composited_layer.display_items: continue

        # 부모 효과들을 따라 올라가며 트리 재구성
        parent = composited_layer.display_items[0].parent
        while parent:
            new_parent = self.get_latest(parent)  # 업데이트된 효과 가져오기

            if new_parent in new_effects:
                # 이미 생성된 효과 → 자식으로 추가
                new_effects[parent].children.append(current_effect)
                break
            else:
                # 새 효과 → clone하여 트리 구성
                current_effect = new_parent.clone(current_effect)
                new_effects[new_parent] = current_effect
                parent = parent.parent

        if not parent:
            # 최상위 노드 → draw_list에 추가
            self.draw_list.append(current_effect)
```

**예시**:

```
원본 트리:
  Transform(10px, 0)
    Blend(opacity=0.5)
      Layer0 (DrawText, DrawRect)
    Layer1 (DrawText)

재구성된 트리:
  Transform(10px, 0)
    Blend(opacity=0.5)
      DrawCompositedLayer(Layer0)
    DrawCompositedLayer(Layer1)
```

#### 부분 업데이트 (composited_updates)

```python
def run_animation_frame(self, scroll):
    # 애니메이션 업데이트
    for node in tree_to_list(self.nodes, []):
        for (property_name, animation) in node.animations.items():
            value = animation.animate()
            if value:
                node.style[property_name] = value
                self.composited_updates.append(node)  # ← 변경된 노드 기록
                self.set_needs_paint()  # paint만 필요

    # style이나 layout이 변경되었는지 확인
    needs_composite = self.needs_style or self.needs_layout

    self.render()

    # CommitData 생성
    composited_updates = None
    if not needs_composite:
        # 전체 컴포지팅 불필요 → 부분 업데이트 전달
        composited_updates = {}
        for node in self.composited_updates:
            composited_updates[node] = node.blend_op  # 최신 Blend 효과

    self.composited_updates = []
    commit_data = CommitData(..., composited_updates)
```

```python
def commit(self, tab, data):
    # ...
    self.composited_updates = data.composited_updates

    if self.composited_updates == None:
        # 전체 컴포지팅 필요
        self.set_needs_composite()
    else:
        # 부분 업데이트만 → draw_list 재구성만
        self.set_needs_draw()

def get_latest(self, effect):
    """업데이트된 효과 가져오기"""
    node = effect.node

    if node not in self.composited_updates:
        return effect  # 변경 없음

    if not isinstance(effect, Blend):
        return effect  # Blend만 업데이트 가능

    # 업데이트된 Blend 효과 반환
    return self.composited_updates[node]
```

**흐름**:

```
1. opacity 애니메이션:
   node.style["opacity"] = "0.51"
   composited_updates.append(node)
   ↓
2. render():
   paint_visual_effects() 호출
   새 Blend(opacity=0.51) 생성
   node.blend_op = new_blend
   ↓
3. commit():
   composited_updates = {node: new_blend}
   set_needs_draw() (composite 스킵!)
   ↓
4. paint_draw_list():
   get_latest(old_blend) → new_blend
   트리 재구성
   ↓
5. raster_tab():
   레이어는 재사용 (래스터화 스킵!)
   ↓
6. draw():
   새 opacity로 합성
```

### 5. 렌더링 파이프라인 세분화

#### 더티 플래그 분리

```diff
 class Tab:
     def __init__(self):
-        self.needs_render = False
+        self.needs_style = False   # CSS 재계산 필요
+        self.needs_layout = False  # 레이아웃 재계산 필요
+        self.needs_paint = False   # 페인트 재실행 필요
```

```python
def set_needs_render(self):
    """스타일부터 다시 계산"""
    self.needs_style = True
    self.browser.set_needs_animation_frame(self)

def set_needs_layout(self):
    """레이아웃부터 다시 계산"""
    self.needs_layout = True
    self.browser.set_needs_animation_frame(self)

def set_needs_paint(self):
    """페인트만 다시 실행"""
    self.needs_paint = True
    self.browser.set_needs_animation_frame(self)
```

#### render() 최적화

```diff
     def render(self):
-        if not self.needs_render: return
-
-        style(self.nodes, ...)
-        self.document = DocumentLayout(self.nodes)
-        self.document.layout()
-        self.display_list = []
-        paint_tree(self.document, self.display_list)
-        self.needs_render = False
+        # 단계별로 필요한 부분만 실행
+        if self.needs_style:
+            style(self.nodes, sorted(self.rules, key=cascade_priority), self)
+            self.needs_layout = True  # style 변경 → layout 필요
+            self.needs_style = False
+
+        if self.needs_layout:
+            self.document = DocumentLayout(self.nodes)
+            self.document.layout()
+            self.needs_paint = True  # layout 변경 → paint 필요
+            self.needs_layout = False
+
+        if self.needs_paint:
+            self.display_list = []
+            paint_tree(self.document, self.display_list)
+            self.needs_paint = False
```

**최적화 효과**:

| 변경 유형          | 실행 단계                         | 시간       |
| ------------------ | --------------------------------- | ---------- |
| innerHTML 변경     | style + layout + paint            | 65ms       |
| width 변경         | layout + paint                    | 35ms       |
| opacity 애니메이션 | paint만 (compositing 사용 시 2ms) | 15ms → 2ms |

### 6. VisualEffect 계층 구조

#### PaintCommand vs VisualEffect

```python
class PaintCommand:
    """실제 그리기 명령 (DrawText, DrawRect 등)"""
    def __init__(self, rect):
        self.rect = rect
        self.children = []

class VisualEffect:
    """시각 효과 (Blend, Transform 등)"""
    def __init__(self, rect, children, node=None):
        self.rect = rect.makeOffset(0.0, 0.0)
        self.children = children
        for child in self.children:
            self.rect.join(child.rect)  # 자식들의 범위 합치기

        self.node = node  # DOM 노드 참조

        # 자식 중 하나라도 compositing 필요하면 부모도 필요
        self.needs_compositing = any([
            child.needs_compositing for child in self.children
            if isinstance(child, VisualEffect)
        ])
```

#### Blend 클래스 확장

```diff
-class Blend:
-    def __init__(self, opacity, blend_mode, children):
+class Blend(VisualEffect):
+    def __init__(self, opacity, blend_mode, node, children):
+        super().__init__(skia.Rect.MakeEmpty(), children, node)
         self.opacity = opacity
         self.blend_mode = blend_mode
         self.should_save = self.blend_mode or self.opacity < 1
+
+        # saveLayer 사용 → 별도 레이어 필요 → compositing
+        if self.should_save:
+            self.needs_compositing = True
+
+    def clone(self, child):
+        """자식을 교체한 복사본 생성 (paint_draw_list에서 사용)"""
+        return Blend(self.opacity, self.blend_mode, self.node, [child])
+
+    def map(self, rect):
+        """로컬 좌표 → 부모 좌표"""
+        # overflow: clip인 경우 clipping 적용
+        if self.children and \
+           isinstance(self.children[-1], Blend) and \
+           self.children[-1].blend_mode == "destination-in":
+            bounds = rect.makeOffset(0.0, 0.0)
+            bounds.intersect(self.children[-1].rect)
+            return bounds
+        return rect
+
+    def unmap(self, rect):
+        """부모 좌표 → 로컬 좌표"""
+        return rect
```

### 7. JavaScript API 확장

#### element.style setter

**runtime.js**:

```diff
+Object.defineProperty(Node.prototype, "style", {
+  set: function (s) {
+    call_python("style_set", this.handle, s.toString());
+  },
+});
```

**browser.py**:

```diff
 class JSContext:
     def __init__(self, tab):
+        self.interp.export_function("style_set", self.style_set)
+
+    def style_set(self, handle, s):
+        """JavaScript에서 element.style = "..." 호출 시"""
+        elt = self.handle_to_node[handle]
+        elt.attributes["style"] = s  # 인라인 스타일 설정
+        self.tab.set_needs_render()
```

**사용 예시**:

```javascript
// JavaScript
var box = document.querySelectorAll(".box")[0];
box.style = "opacity: 0.5; transition: opacity 1s";
```

### 8. 브라우저 플래그 시스템 개선

```diff
 class Browser:
     def __init__(self):
         self.needs_animation_frame = False
-        self.needs_raster_and_draw = False
+        self.needs_composite = False  # 컴포지팅 필요
+        self.needs_raster = False     # 래스터화 필요
+        self.needs_draw = False       # 그리기 필요
+
+    def set_needs_composite(self):
+        """전체 파이프라인 실행"""
+        self.needs_composite = True
+        self.needs_raster = True
+        self.needs_draw = True
+
+    def set_needs_raster(self):
+        """래스터화부터 실행"""
+        self.needs_raster = True
+        self.needs_draw = True
+
+    def set_needs_draw(self):
+        """그리기만 실행"""
+        self.needs_draw = True
```

```diff
-    def raster_and_draw(self):
+    def composite_raster_and_draw(self):
         self.lock.acquire(blocking=True)
-        if not self.needs_raster_and_draw:
+        if not self.needs_composite and \
+            not self.needs_raster and \
+            not self.needs_draw:
             self.lock.release()
             return
+
+        if self.needs_composite:
+            self.composite()  # 레이어 분할
+            self.needs_composite = False
+
+        if self.needs_raster:
+            self.raster_chrome()
+            self.raster_tab()  # 레이어들 래스터화
+            self.needs_raster = False
+
+        if self.needs_draw:
+            self.paint_draw_list()  # 효과 트리 재구성
+            self.draw()
+            self.needs_draw = False
+
-        self.raster_chrome()
-        self.raster_tab()
-        self.draw()
-        self.needs_raster_and_draw = False
         self.lock.release()
```

## 전체 파이프라인 흐름

### 전체 렌더링 (needs_composite = True)

```
1. Tab 스레드: innerHTML 변경
   ↓
2. set_needs_render() → needs_style = True
   ↓
3. run_animation_frame()
   - style() 실행 (30ms)
   - layout() 실행 (20ms)
   - paint() 실행 (15ms)
   - commit(composited_updates=None)
   ↓
4. Browser 스레드: commit()
   - composited_updates == None
   - set_needs_composite()
   ↓
5. composite_raster_and_draw()
   - composite() - 레이어 분할 (5ms)
   - raster_tab() - 레이어 래스터화 (10ms)
   - paint_draw_list() - 트리 재구성 (2ms)
   - draw() - 화면 그리기 (3ms)
   ↓
총 85ms (30 FPS 미만)
```

### 부분 업데이트 (opacity 애니메이션)

```
1. Tab 스레드: 애니메이션 프레임
   ↓
2. animation.animate() → "0.51"
   node.style["opacity"] = "0.51"
   composited_updates.append(node)
   set_needs_paint() → needs_paint = True
   ↓
3. run_animation_frame()
   - style() 스킵
   - layout() 스킵
   - paint() 실행 (15ms) - 새 Blend 효과 생성
   - commit(composited_updates={node: new_blend})
   ↓
4. Browser 스레드: commit()
   - composited_updates != None
   - set_needs_draw() (composite, raster 스킵!)
   ↓
5. composite_raster_and_draw()
   - composite() 스킵
   - raster_tab() 스킵 (레이어 재사용)
   - paint_draw_list() - 트리 재구성 (2ms)
   - draw() - 화면 그리기 (3ms)
   ↓
총 20ms (50 FPS)
```

## 주요 개념 정리

### 1. 컴포지팅 (Compositing)

**정의**: 화면을 여러 독립적인 레이어로 분할하여 각각 래스터화하고, 최종적으로 합성하는 기법

**장점**:

- 일부 레이어만 변경 → 전체 재렌더링 불필요
- GPU 가속 활용
- 애니메이션 최적화

**단점**:

- 메모리 사용 증가 (레이어마다 텍스처)
- 복잡도 증가

### 2. 더티 플래그 (Dirty Flags)

**정의**: 무엇이 변경되었는지 추적하여 필요한 부분만 재계산

```
needs_style:  CSS 변경
needs_layout: 크기/위치 변경
needs_paint:  시각 효과 변경
```

**효과**:

- opacity 애니메이션: paint만 → 15ms
- transform 애니메이션: composited → 2ms

### 3. GPU 가속

**렌더링 파이프라인**:

```
CPU: Display List 생성
  ↓
GPU: Composited Layer 래스터화 (병렬)
  ↓
GPU: Layer 합성 (blend modes)
  ↓
GPU: 화면 출력 (vsync)
```

**특징**:

- 수천 개의 코어로 병렬 처리
- 텍스처 캐싱
- 하드웨어 블렌딩

### 4. 선형 보간 (Linear Interpolation)

**공식**:

```
value(t) = start + (end - start) * t
```

**예시** (opacity 1.0 → 0.5, 30 프레임):

```
frame 0:  1.0
frame 15: 1.0 + (0.5 - 1.0) * (15/30) = 0.75
frame 30: 1.0 + (0.5 - 1.0) * (30/30) = 0.5
```

## 실전 예시

### 예시 1: Fade 애니메이션

```html
<style>
  .box {
    opacity: 1;
    transition: opacity 1s;
  }
</style>

<div class="box" id="mybox">Hello</div>

<script>
  setTimeout(function () {
    var box = document.querySelectorAll("#mybox")[0];
    box.style = "opacity: 0.0; transition: opacity 1s";
  }, 1000);
</script>
```

**실행 흐름**:

```
0ms: 페이지 로드
  - style(): opacity = 1.0, transition = "opacity 1s"
  - node.animations = {}

1000ms: setTimeout 실행
  - style_set("opacity: 0.0; transition: opacity 1s")
  - style(): diff_styles() → ("1.0", "0.0", 30)
  - NumericAnimation 생성
  - node.animations["opacity"] = animation

1033ms: 프레임 1
  - animation.animate() → "0.983"
  - node.style["opacity"] = "0.983"
  - composited_updates = [node]

1066ms: 프레임 2
  - animation.animate() → "0.967"
  ...

2000ms: 프레임 30
  - animation.animate() → None (완료)
  - node.animations.pop("opacity")
```

### 예시 2: Transform 애니메이션

```javascript
var box = document.querySelectorAll(".box")[0];
var pos = 0;

function animate() {
  pos += 1;
  box.style = "transform: translate(" + pos + "px, 0px)";
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

**매 프레임**:

```
1. style_set("transform: translate(1px, 0px)")
   ↓
2. set_needs_render() → needs_style = True
   ↓
3. run_animation_frame()
   - style() - 1ms
   - layout() - 20ms (transform은 layout 영향 없음... 하지만 실행됨)
   - paint() - 15ms
   ↓
4. composite() - 5ms
   ↓
5. raster_tab() - 10ms
   ↓
총 51ms (19 FPS)
```

**최적화 방안**: transform은 layout에 영향 없으므로 layout 스킵 가능 (향후 개선)

## 요약

1. **OpenGL 도입**: CPU → GPU 렌더링으로 10-100배 성능 향상
2. **애니메이션**: CSS transition으로 부드러운 시각 효과
3. **컴포지팅**: 레이어 분할로 부분 업데이트 최적화 (7-42배 향상)
4. **Transform**: translate 지원으로 요소 이동
5. **더티 플래그**: style/layout/paint 분리로 불필요한 계산 제거
