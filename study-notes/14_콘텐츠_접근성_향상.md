# 콘텐츠 접근성 향상

## 개요

- 접근성 트리(Accessibility Tree) 구현
- 음성 출력(Text-to-Speech) 기능
- 키보드 네비게이션 개선
- 다크 모드 지원
- 줌(확대/축소) 기능
- 포커스 관리 시스템

---

## 주요 변경 사항

### 1. 새로운 라이브러리 추가

```diff
 import ctypes
+import gtts
 import math
+import os
+import playsound3
 import sdl2
```

**설명**:

- `gtts` (Google Text-to-Speech): 텍스트를 음성으로 변환하기 위한 라이브러리
- `playsound3`: 생성된 음성 파일을 재생하기 위한 라이브러리
- `os`: 임시 음성 파일 삭제 등 파일 시스템 작업을 위해 사용

---

### 2. JSContext에 setAttribute 함수 추가

```diff
         self.interp.export_function("getAttribute",
             self.getAttribute)
+        self.interp.export_function("setAttribute",
+            self.setAttribute)
         self.interp.export_function("innerHTML_set", self.innerHTML_set)
```

```diff
+    def setAttribute(self, handle, attr, value):
+        elt = self.handle_to_node[handle]
+        elt.attributes[attr] = value
+        self.tab.set_needs_render()
```

**설명**: JavaScript에서 DOM 요소의 속성을 설정할 수 있도록 `setAttribute` 함수를 추가했습니다. 이를 통해 JavaScript가 HTML 요소의 속성을 동적으로 변경할 수 있습니다.

---

### 3. CSS 파서 개선 - 의사 클래스(Pseudoclass) 지원

```diff
-    def selector(self):
+    def simple_selector(self):
         out = TagSelector(self.word().casefold())
+        if self.i < len(self.s) and self.s[self.i] == ":":
+            self.literal(":")
+            pseudoclass = self.word().casefold()
+            out = PseudoclassSelector(pseudoclass, out)
+        return out
+
+    def selector(self):
+        out = self.simple_selector()
         self.whitespace()
         while self.i < len(self.s) and self.s[self.i] != "{":
-            tag = self.word()
-            descendant = TagSelector(tag.casefold())
+            descendant = self.simple_selector()
             out = DescendantSelector(out, descendant)
             self.whitespace()
         return out
```

```diff
+class PseudoclassSelector:
+    def __init__(self, pseudoclass, base):
+        self.pseudoclass = pseudoclass
+        self.base = base
+        self.priority = self.base.priority
+
+    def matches(self, node):
+        if not self.base.matches(node):
+            return False
+        if self.pseudoclass == "focus":
+            return node.is_focused
+        else:
+            return False
```

**설명**: CSS 의사 클래스(`:focus` 등)를 지원하도록 파서를 개선했습니다. 이를 통해 포커스된 요소에 대한 스타일을 별도로 지정할 수 있습니다.

---

### 4. CSS 파서 개선 - 미디어 쿼리 지원

```diff
+    def media_query(self):
+        self.literal("@")
+        assert self.word() == "media"
+        self.whitespace()
+        self.literal("(")
+        self.whitespace()
+        prop, val = self.pair([")"])
+        self.whitespace()
+        self.literal(")")
+        return prop, val
+
     def parse(self):
         rules = []
+        media = None
+        self.whitespace()
         while self.i < len(self.s):
             try:
-                self.whitespace()
-                selector = self.selector()
-                self.literal("{")
-                self.whitespace()
-                body = self.body()
-                self.literal("}")
-                rules.append((selector, body))
+                if self.s[self.i] == "@" and not media:
+                    prop, val = self.media_query()
+                    if prop == "prefers-color-scheme" and \
+                        val in ["dark", "light"]:
+                        media = val
+                    self.whitespace()
+                    self.literal("{")
+                    self.whitespace()
+                elif self.s[self.i] == "}" and media:
+                    self.literal("}")
+                    media = None
+                    self.whitespace()
+                else:
+                    selector = self.selector()
+                    self.literal("{")
+                    self.whitespace()
+                    body = self.body()
+                    self.literal("}")
+                    self.whitespace()
+                    rules.append((media, selector, body))
```

**설명**: `@media (prefers-color-scheme: dark)` 같은 미디어 쿼리를 파싱할 수 있게 되었습니다. 다크 모드 지원을 위한 기반이 됩니다.

---

### 5. 노드에 layout_object 참조 추가

```diff
 class Text:
     def __init__(self, text, parent):
         self.text = text
         self.children = []
         self.parent = parent
         self.is_focused = False
         self.style = {}
         self.animations = {}
+        self.layout_object = None
```

```diff
 class Element:
     def __init__(self, tag, attributes, parent):
         self.tag = tag
         self.attributes = attributes
         self.children = []
         self.parent = parent
         self.is_focused = False
         self.style = {}
         self.animations = {}
+        self.layout_object = None
```

**설명**: 각 노드가 자신의 레이아웃 객체를 참조할 수 있도록 했습니다. 이는 접근성 트리에서 노드의 화면상 위치를 계산하는 데 필요합니다.

---

### 6. 줌(Zoom) 기능 구현

```diff
+def dpx(css_px, zoom):
+    return css_px * zoom
```

**설명**: CSS 픽셀을 디바이스 픽셀로 변환하는 함수입니다. 줌 레벨에 따라 크기를 조정합니다.

레이아웃 클래스들에 줌 지원 추가:

```diff
     def layout(self):
+        self.zoom = self.parent.zoom
         weight = self.node.style["font-weight"]
         style = self.node.style["font-style"]
         if style == "normal": style = "roman"
-        size = int(float(self.node.style["font-size"][:-2]) * .75)
+        px_size = float(self.node.style["font-size"][:-2])
+        size = dpx(px_size * 0.75, self.zoom)
         self.font = get_font(size, weight, style)
```

**설명**: 모든 레이아웃 객체가 줌 레벨을 추적하고, 크기 계산 시 이를 반영합니다.

---

### 7. 다크 모드 지원

```diff
 def style(node, rules, tab):
     old_style = node.style

     node.style = {}
     for property, default_value in INHERITED_PROPERTIES.items():
         if node.parent:
             node.style[property] = node.parent.style[property]
         else:
             node.style[property] = default_value
-    for selector, body in rules:
+    for media, selector, body in rules:
+        if media:
+            if (media == "dark") != tab.dark_mode: continue
         if not selector.matches(node): continue
```

```diff
     def render(self):
         self.browser.measure.time('render')

         if self.needs_style:
+            if self.dark_mode:
+                INHERITED_PROPERTIES["color"] = "white"
+            else:
+                INHERITED_PROPERTIES["color"] = "black"
             style(self.nodes, sorted(self.rules, key=cascade_priority), self)
```

**설명**: 다크 모드가 활성화되면 기본 텍스트 색상을 흰색으로 변경하고, 미디어 쿼리에서 다크 모드 CSS 규칙을 적용합니다.

---

### 8. 접근성 트리(AccessibilityNode) 구현

```diff
+class AccessibilityNode:
+    def __init__(self, node):
+        self.node = node
+        self.children = []
+        self.bounds = self.compute_bounds()
+
+        if isinstance(node, Text):
+            if is_focusable(node.parent):
+                self.role = "focusable text"
+            else:
+                self.role = "StaticText"
+        else:
+            if "role" in node.attributes:
+                self.role = node.attributes["role"]
+            elif node.tag == "a":
+                self.role = "link"
+            elif node.tag == "input":
+                self.role = "textbox"
+            elif node.tag == "button":
+                self.role = "button"
+            elif node.tag == "html":
+                self.role = "document"
+            elif is_focusable(node):
+                self.role = "focusable"
+            else:
+                self.role = "none"
```

**설명**:

- 접근성 트리는 스크린 리더 등 보조 기술이 사용할 수 있는 구조화된 정보를 제공합니다
- 각 노드에 적절한 역할(role)을 부여합니다 (link, button, textbox 등)
- 노드의 화면상 경계(bounds)를 계산합니다

```diff
+    def compute_bounds(self):
+        if self.node.layout_object:
+            return [absolute_bounds_for_obj(self.node.layout_object)]
+        if isinstance(self.node, Text):
+            return []
+        inline = self.node.parent
+        bounds = []
+        while not inline.layout_object: inline = inline.parent
+        for line in inline.layout_object.children:
+            line_bounds = skia.Rect.MakeEmpty()
+            for child in line.children:
+                if child.node.parent == self.node:
+                    line_bounds.join(skia.Rect.MakeXYWH(
+                        child.x, child.y, child.width, child.height))
+            bounds.append(line_bounds)
+        return bounds
```

**설명**: 노드의 화면상 위치를 계산합니다. 인라인 요소의 경우 여러 줄에 걸쳐 표시될 수 있으므로 여러 bounds를 가질 수 있습니다.

```diff
+    def hit_test(self, x, y):
+        node = None
+        if self.contains_point(x, y):
+            node = self
+        for child in self.children:
+            res = child.hit_test(x, y)
+            if res: node = res
+        return node
```

**설명**: 특정 좌표에 위치한 접근성 노드를 찾습니다. 마우스 호버 시 어떤 요소가 포커스되어야 하는지 결정하는 데 사용됩니다.

---

### 9. Outline(외곽선) 지원

```diff
+def parse_outline(outline_str):
+    if not outline_str: return None
+    values = outline_str.split(" ")
+    if len(values) != 3: return None
+    if values[1] != "solid": return None
+    return int(values[0][:-2]), values[2]
+
+def paint_outline(node, cmds, rect, zoom):
+    outline = parse_outline(node.style.get("outline"))
+    if not outline: return
+    thickness, color = outline
+    cmds.append(DrawOutline(rect, color, dpx(thickness, zoom)))
```

**설명**: CSS outline 속성을 지원합니다. 포커스된 요소 주위에 외곽선을 그려 시각적 피드백을 제공합니다.

---

### 10. 포커스 관리 개선

```diff
+def get_tabindex(node):
+    tabindex = int(node.attributes.get("tabindex", "9999999"))
+    return 9999999 if tabindex == 0 else tabindex
+
+def is_focusable(node):
+    if get_tabindex(node) < 0:
+        return False
+    elif "tabindex" in node.attributes:
+        return True
+    else:
+        return node.tag in ["input", "button", "a"]
```

**설명**:

- `tabindex` 속성을 고려하여 요소가 포커스 가능한지 판단합니다
- 기본적으로 input, button, a 태그는 포커스 가능합니다
- `tabindex="-1"`인 요소는 포커스 불가능합니다

```diff
+    def focus_element(self, node):
+        if node and node != self.focus:
+            self.needs_focus_scroll = True
+        if self.focus:
+            self.focus.is_focused = False
+        self.focus = node
+        if node:
+            node.is_focused = True
```

**설명**:

- 요소에 포커스를 설정할 때 이전 포커스를 해제합니다
- 새로 포커스된 요소로 스크롤해야 하는지 표시합니다

```diff
+    def activate_element(self, elt):
+        if elt.tag == "input":
+            elt.attributes["value"] = ""
+            self.set_needs_render()
+        elif elt.tag == "a" and "href" in elt.attributes:
+            url = self.url.resolve(elt.attributes["href"])
+            self.load(url)
+        elif elt.tag == "button":
+            while elt:
+                if elt.tag == "form" and "action" in elt.attributes:
+                    self.submit_form(elt)
+                    return
+                elt = elt.parent
```

**설명**: 요소 타입에 따라 적절한 활성화 동작을 수행합니다 (링크 따라가기, 버튼 클릭, 입력 필드 활성화).

---

### 11. 키보드 네비게이션 - Tab 키 지원

```diff
+    def advance_tab(self):
+        focusable_nodes = [node
+            for node in tree_to_list(self.nodes, [])
+            if isinstance(node, Element) and is_focusable(node)]
+        focusable_nodes.sort(key=get_tabindex)
+
+        if self.focus in focusable_nodes:
+            idx = focusable_nodes.index(self.focus) + 1
+        else:
+            idx = 0
+
+        if idx < len(focusable_nodes):
+            self.focus_element(focusable_nodes[idx])
+        else:
+            self.focus_element(None)
+            self.browser.focus_addressbar()
+        self.set_needs_render()
```

**설명**:

- Tab 키를 누르면 다음 포커스 가능한 요소로 이동합니다
- `tabindex` 순서에 따라 정렬됩니다
- 마지막 요소 이후에는 주소창으로 포커스가 이동합니다

---

### 12. 포커스 스크롤

```diff
+    def scroll_to(self, elt):
+        objs = [
+            obj for obj in tree_to_list(self.document, [])
+            if obj.node == self.focus
+        ]
+        if not objs: return
+        obj = objs[0]
+
+        if self.scroll < obj.y < self.scroll + self.tab_height:
+            return
+
+        document_height = math.ceil(self.document.height + 2*VSTEP)
+        new_scroll = obj.y - SCROLL_STEP
+        self.scroll = self.clamp_scroll(new_scroll)
+        self.scroll_changed_in_tab = True
```

**설명**: 포커스된 요소가 화면 밖에 있으면 자동으로 스크롤하여 보이도록 합니다.

---

### 13. 줌 제어 기능

```diff
+    def zoom_by(self, increment):
+        if increment:
+            self.zoom *= 1.1
+            self.scroll *= 1.1
+        else:
+            self.zoom *= 1/1.1
+            self.scroll *= 1/1.1
+        self.scroll_changed_in_tab = True
+        self.set_needs_render()
+
+    def reset_zoom(self):
+        self.scroll /= self.zoom
+        self.zoom = 1
+        self.scroll_changed_in_tab = True
+        self.set_needs_render()
```

**설명**:

- 페이지를 확대/축소할 수 있습니다
- 줌 변경 시 스크롤 위치도 비례하여 조정됩니다
- 줌을 초기화할 수 있습니다

---

### 14. 음성 출력(Text-to-Speech) 기능

```diff
+SPEECH_FILE = "/tmp/speech-fragment.mp3"
+
+def speak_text(text):
+    print("SPEAK:", text)
+    tts = gtts.gTTS(text)
+    tts.save(SPEECH_FILE)
+    if playsound3:
+        playsound3.playsound(SPEECH_FILE)
+    os.remove(SPEECH_FILE)
```

**설명**:

- Google TTS를 사용하여 텍스트를 음성으로 변환합니다
- 임시 파일에 저장 후 재생하고 삭제합니다
- 스크린 리더 기능의 일부로 사용됩니다

---

### 15. 접근성 기능 통합

```diff
+        self.needs_accessibility = False
+        self.needs_speak_hovered_node = False
+        self.accessibility_is_on = False
+        self.has_spoken_document = False
+        self.tab_focus = None
+        self.last_tab_focus = None
+        self.active_alerts = []
+        self.spoken_alerts = []
+        self.pending_hover = None
+        self.hovered_a11y_node = None
```

**설명**: 브라우저에 접근성 관련 상태 변수들을 추가했습니다.

```diff
+    def handle_hover(self, event):
+        if not self.accessibility_is_on or \
+            not self.accessibility_tree:
+            return
+        self.pending_hover = (event.x, event.y - self.chrome.bottom)
+        self.set_needs_accessibility()
```

**설명**: 마우스 호버 시 접근성 노드를 찾아 하이라이트하고 음성으로 읽어줍니다.

```diff
+    def toggle_accessibility(self):
+        self.lock.acquire(blocking=True)
+        self.accessibility_is_on = not self.accessibility_is_on
+        self.set_needs_accessibility()
+        self.lock.release()
```

**설명**: 접근성 기능을 켜고 끌 수 있습니다.

---

### 16. 다크 모드 Chrome UI 지원

```diff
     def paint(self):
+        if self.browser.dark_mode:
+            color = "white"
+        else:
+            color = "black"
+
         cmds = []
-        cmds.append(DrawRect(
-            skia.Rect.MakeLTRB(0, 0, WIDTH, self.bottom),
-            "white"))
         cmds.append(DrawLine(
             0, self.bottom, WIDTH,
-            self.bottom, "black", 1))
+            self.bottom, color, 1))
```

**설명**: 브라우저 UI (Chrome)도 다크 모드를 지원하도록 수정했습니다.

---

## 접근성 향상의 의미

이번 변경을 통해 브라우저는 다음과 같은 접근성 기능을 제공하게 되었습니다:

1. **스크린 리더 지원**: 접근성 트리를 통해 스크린 리더가 페이지 내용을 이해하고 읽을 수 있습니다
2. **키보드 네비게이션**: 마우스 없이 Tab 키로 모든 요소에 접근할 수 있습니다
3. **시각적 피드백**: 포커스된 요소에 외곽선을 표시하여 현재 위치를 명확히 합니다
4. **줌 기능**: 시력이 약한 사용자가 콘텐츠를 확대하여 볼 수 있습니다
5. **다크 모드**: 눈의 피로를 줄이고 다양한 시각적 선호도를 지원합니다
6. **자동 스크롤**: 포커스된 요소가 항상 화면에 보이도록 합니다

이러한 기능들은 장애가 있는 사용자뿐만 아니라 모든 사용자의 경험을 개선합니다.
