# CSRF와 SameSite, 그리고 웹 보안의 다층 방어 체계

## 1. CSRF 공격의 본질: '내 권한'을 '남'이 사용하는 것

CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)는 공격자가 사용자의 쿠키 값을 **훔치거나 알아내는 공격이 아닙니다.** 그 본질은 **웹 브라우저가 가진 서버에 대한 신뢰**를 악용하는 것입니다.

### 핵심 원리

1.  사용자가 정상적인 웹사이트 `A.com`에 로그인하면, 브라우저는 `A.com` 전용 '자동 출입증'(인증 쿠키)을 발급받아 저장합니다.
2.  이후 브라우저는 `A.com`으로 요청을 보낼 때마다, 사용자의 편의를 위해 이 쿠키를 자동으로 첨부합니다.
3.  공격자는 악성 웹사이트 `B.com`에 "A.com으로 특정 행동(송금, 글 삭제 등)을 요청하는 코드"를 숨겨둡니다.
4.  사용자가 `A.com`에 로그인된 상태로 `B.com`을 방문하면, 숨겨진 코드가 작동하여 `A.com`으로 요청이 전송됩니다.
5.  이때 브라우저는 아무 의심 없이 자신이 보관하던 **진짜 쿠키를 붙여서** `A.com`으로 요청을 보냅니다.
6.  `A.com` 서버는 진짜 쿠키가 포함된 요청을 받았으므로, 이를 정상적인 사용자의 의도된 행동으로 착각하고 악의적인 요청을 그대로 처리합니다.

결론적으로, 공격자의 목표는 데이터 탈취가 아닌, **사용자의 권한을 도용하여 서버의 상태를 변경(State Change)**하는 것입니다.

### 구체적인 공격 코드 예시

```html
<!-- evil-site.com에 숨겨진 악성 코드 -->

<!-- Case 1: GET 요청을 이용한 공격 (서버가 잘못 구현된 경우) -->
<img src="https://bank.com/transfer?to=attacker&amount=1000000" style="display:none" />

<!-- Case 2: POST 요청을 이용한 자동 제출 폼 -->
<form action="https://bank.com/transfer" method="POST" id="csrf-form">
  <input type="hidden" name="to" value="attacker" />
  <input type="hidden" name="amount" value="1000000" />
</form>
<script>
  document.getElementById("csrf-form").submit();
</script>
```

## 2. `SameSite` 속성: 브라우저 레벨의 1차 방어선

`SameSite`는 CSRF를 막기 위한 가장 직접적이고 효과적인 방어 수단입니다. 이 정책은 서버가 쿠키에 정책을 명시하면, **클라이언트(브라우저)**가 강제합니다.

### `SameSite` 값들의 비교

| 값       | 설명                                                                                                             | 장점                                                | 단점                                                          |
| :------- | :--------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------- | :------------------------------------------------------------ |
| `Strict` | 가장 강력한 정책. `<a>` 링크 클릭을 포함한 **모든 Cross-Site 요청**에 쿠키 전송을 차단.                          | 최고의 보안성                                       | 외부 링크를 통한 접속 시 로그인이 풀리는 등 사용자 경험 저하. |
| `Lax`    | 보안과 편의성의 절충안. 위험한 요청(`POST`)은 막되, `GET` 방식의 최상위 탐색(링크 클릭 등)에는 쿠키 전송을 허용. | 대부분의 CSRF를 막으면서 사용자 경험을 해치지 않음. | `GET` 요청으로 상태를 변경하는 서버에는 취약.                 |
| `None`   | 과거의 동작 방식. 모든 Cross-Site 요청에 쿠키를 허용. **반드시 `Secure` 속성(HTTPS)을 함께 사용**해야 함.        | 서드파티 서비스 연동에 유리.                        | CSRF 방어 효과 없음.                                          |

### 브라우저의 기본 정책 변화

- **과거:** `SameSite` 속성을 명시하지 않으면 `None`과 동일하게 동작하여 CSRF에 취약했습니다.
- **현재 (Chrome 80+):** `SameSite` 속성이 없으면 **자동으로 `Lax`가 적용**됩니다. 이로 인해 `SameSite=None; Secure` 설정이 없는 서드파티 쿠키 기반 인증이 갑자기 동작하지 않는 이슈가 발생하기도 했습니다.

## 3. 보완 방어 계층: CSRF 토큰

`SameSite` 쿠키만으로 완벽하지 않을 수 있습니다. 구형 브라우저를 지원하거나, `SameSite=None`을 사용해야 하는 경우 **CSRF 토큰**이라는 추가적인 방어 계층이 반드시 필요합니다.

### 원리: 요청의 출처와 의도를 한 번 더 검증

서버는 사용자의 세션과 연관된 예측 불가능한 토큰을 생성합니다. 클라이언트는 데이터를 변경하는 요청을 보낼 때마다 이 토큰을 함께 전송해야 합니다. 공격자는 이 토큰 값을 알 수 없으므로 요청 위조가 불가능합니다. **"쿠키가 아닌 다른 채널로 토큰을 보내 서버에서 검증한다"**는 것이 핵심 보안 원칙입니다.

### 아키텍처별 구현 방식의 차이

#### 전통적인 MPA (Multi-Page App) 방식

- **동작:** 사용자가 페이지를 요청할 때마다 서버는 새로운 HTML 문서를 렌더링합니다. 이때 서버는 각 폼에 맞는 새로운 CSRF 토큰을 `hidden` 필드에 쉽게 삽입하여 보내줄 수 있습니다.
- **구현:**
  ```html
  <form action="/update-profile" method="post">
    <input type="hidden" name="csrf_token" value="a1b2c3d4e5f6..." />
    <!-- ... other form fields ... -->
  </form>
  ```

#### 모던 SPA (Single-Page App) 방식

SPA는 페이지 새로고침 없이 API를 통해 데이터만 교환하므로, "세션 단위의 API 요청 토큰" 개념으로 CSRF를 방어합니다.

- **패턴 1: API 헤더를 이용한 토큰 전송 (가장 일반적)**

  1.  **토큰 발급:** 사용자가 로그인하면, 서버는 응답 데이터(JSON)에 CSRF 토큰을 포함시켜 전달합니다.
  2.  **토큰 저장:** 클라이언트는 이 토큰을 자바스크립트 변수 등에 저장합니다.
  3.  **토큰 사용:** 이후 데이터를 변경하는 모든 API 요청의 **HTTP 헤더(예: `X-CSRF-TOKEN`)**에 토큰을 담아 전송합니다.
  4.  **서버 검증:** 서버는 사용자의 세션과 요청 헤더에 담긴 토큰 값을 비교하여 검증합니다. 공격자는 SOP 때문에 이 토큰 값을 알아내 헤더에 담을 수 없습니다.

- **패턴 2: Double Submit Cookie 패턴**
  1.  **토큰 발급:** 서버는 두 개의 쿠키를 발급합니다. 하나는 `HttpOnly`가 걸린 세션 쿠키, 다른 하나는 **`HttpOnly`가 없는** CSRF 토큰 쿠키입니다.
  2.  **토큰 사용:** 클라이언트는 자바스크립트로 CSRF 토큰 쿠키의 값을 읽어, API 요청 시 **HTTP 헤더**에 그 값을 복사해서 넣어 보냅니다.
  3.  **서버 검증:** 서버는 **쿠키로 전달된 토큰**과 **헤더로 전달된 토큰**의 값이 일치하는지 비교합니다. 공격자는 쿠키 값을 읽을 수 없으므로 헤더 값을 위조할 수 없습니다.

## 4. SOP, CORS와의 관계: 각자의 역할과 한계

SOP, CORS, `SameSite`는 서로 다른 공격을 막기 위해 상호 보완적으로 동작합니다.

### SOP (Same-Origin Policy): '읽기(Read)' 방어막

- **역할:** 한 출처(`evil-site.com`)의 스크립트가 다른 출처(`bank.com`)의 **데이터를 읽지(Read) 못하게** 막아 정보 유출을 방지합니다.
- **한계:** CSRF 요청이 성공하여 DB가 변경되더라도, 공격자는 그 성공 **결과를 읽을 수 없을 뿐**입니다. 요청이 서버로 전송되는 **행위 자체를 막지는 못합니다.**

### CORS (Cross-Origin Resource Sharing): '예외적 읽기' 허용 정책

- **역할:** SOP라는 강력한 차단 정책에 대해 "이 출처는 믿을 수 있으니 예외적으로 데이터 읽기를 허용해 줘"라고 서버가 브라우저에게 알려주는 규칙입니다.
- **프리플라이트 요청 (Preflight Request):** `Content-Type: application/json`과 같은 요청은 브라우저가 본 요청 전에 `OPTIONS` 메서드로 서버에 허락을 구합니다. 서버가 허락하지 않으면 요청은 자동으로 차단되어 CSRF로부터 상대적으로 안전합니다.
- **단순 요청 (Simple Request):** CSRF 공격에 주로 사용되는 전통적인 HTML `<form>` 전송(`POST` 메서드, `application/x-www-form-urlencoded` 타입)은 **프리플라이트를 유발하지 않는 '단순 요청'**입니다. 이 요청은 일단 서버로 전송되므로 CORS의 프리플라이트 방어 메커니즘을 우회합니다.

## 5. 최종 요약: 웹 보안 기술 비교

| 기술                | 주요 역할            | 방어 대상              | 한계 및 실패 케이스                                         |
| :------------------ | :------------------- | :--------------------- | :---------------------------------------------------------- |
| **`SameSite` 쿠키** | **권한 도용 방지**   | **CSRF**               | `GET`으로 상태 변경하는 서버, 구형 브라우저, `None` 설정 시 |
| **CSRF 토큰**       | **요청 출처 검증**   | **CSRF**               | 토큰이 XSS 공격으로 유출되면 무력화                         |
| **SOP**             | **데이터 유출 방지** | **불법적인 정보 읽기** | 위조된 **요청 전송 자체**는 막지 못함                       |
| **CORS**            | **SOP 예외 허용**    | (방어 기술 아님)       | '단순 요청'은 프리플라이트의 보호를 받지 못함               |

결론적으로, 웹 보안은 하나의 기술로 완성되지 않습니다. `SameSite` 쿠키를 기본으로 설정하되, 필요에 따라 CSRF 토큰을 추가하고, 서버 로직을 안전하게 설계하며(GET/POST 역할 구분), SOP와 CORS의 동작을 명확히 이해하는 **다층적인 방어 전략(Defense in Depth)**이 견고한 보안의 핵심입니다.
