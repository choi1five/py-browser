# 1. 타이밍 공격이란 무엇인가?

타이밍 공격의 핵심 아이디어는 간단합니다.

> **"컴퓨터가 특정 연산을 수행하는 데 걸리는 '시간'을 측정하여, 그 시간 차이를 단서로 숨겨진 정보(비밀번호, 암호키 등)를 알아내는 공격 기법"**

마치 금고털이범이 다이얼을 돌리면서 소리의 미세한 차이를 듣고 비밀번호를 알아내는 것과 같습니다. 우리는 암호 연산이 즉각적으로 끝난다고 생각하지만, 실제로는 입력값에 따라 CPU가 수행하는 연산 경로가 미세하게 달라지면서 걸리는 시간도 나노초(nanosecond) 단위로 차이가 발생합니다. 공격자는 이 미세한 시간 차이를 수없이 측정하고 통계적으로 분석하여 비밀을 한 글자씩 추측해 나가는 것입니다.

## 2. 타이밍 공격의 동작 원리: 간단한 비밀번호 비교 예시

타이밍 공격이 어떻게 가능한지, 가장 고전적인 **문자열 비교** 예시를 통해 알아보겠습니다.

### **취약한 코드 (Vulnerable Code):**

대부분의 프로그래머가 무심코 작성하는 일반적인 비밀번호 비교 함수입니다.

```python
# !! 타이밍 공격에 매우 취약한 코드 !!
def insecure_compare(user_input, secret_pin):
  # 입력값과 비밀번호의 길이가 다르면 즉시 실패 처리
  if len(user_input) != len(secret_pin):
    return False

  # 앞에서부터 한 글자씩 비교
  for i in range(len(secret_pin)):
    if user_input[i] != secret_pin[i]:
      # 일치하지 않는 문자를 발견하면 즉시 종료 (Short-circuit)
      return False

  # 모든 문자가 일치하면 성공
  return True
```

이 코드는 효율적이지만, "일치하지 않으면 즉시 종료"하는 로직 때문에 치명적인 타이밍 취약점을 가집니다.

### **공격 시나리오:**

- 서버에 저장된 실제 비밀 PIN: `8421` (4자리)
- 공격자의 목표: PIN `8421`을 알아내기

**1단계: 첫 번째 자리 알아내기**

공격자는 첫 번째 자리가 0~9 중 하나일 것이라고 가정하고, 나머지 자리는 임의의 값으로 채워 요청을 보낸 뒤 응답 시간을 측정합니다.

- `0000`을 입력 → 서버는 `0`과 `8`을 비교하고 **즉시** `False` 반환. (응답 시간: **10ms**)
- `1000`을 입력 → 서버는 `1`과 `8`을 비교하고 **즉시** `False` 반환. (응답 시간: **10ms**)
- ...
- `7000`을 입력 → 서버는 `7`과 `8`을 비교하고 **즉시** `False` 반환. (응답 시간: **10ms**)
- `8000`을 입력 → 서버는 `8`과 `8`을 비교 (**성공!**) → **다음 자리로 넘어감** → `0`과 `4`를 비교하고 `False` 반환. (응답 시간: **12ms**)

**결과:** 공격자는 `8000`을 보냈을 때 응답 시간이 미세하게 더 길어진 것을 관찰합니다. 네트워크 지연(jitter)을 고려해 수백 번 반복하여 통계적 유의미함을 확인한 뒤, **"첫 번째 자리는 8이다!"** 라고 확신하게 됩니다.

**2단계: 두 번째 자리 알아내기**

이제 첫 번째 자리가 `8`이라는 것을 알았으므로, 두 번째 자리를 추측합니다.

- `8000`을 입력 → 두 번째 자리에서 실패. (응답 시간: **12ms**)
- `8100`을 입력 → 두 번째 자리에서 실패. (응답 시간: **12ms**)
- ...
- `8400`을 입력 → `8`==`8` (성공) → `4`==`4` (성공) → **세 번째 자리로 넘어감** → `0`과 `2`를 비교하고 `False` 반환. (응답 시간: **14ms**)

**결과:** 공격자는 `8400`을 보냈을 때 응답 시간이 다시 한번 길어진 것을 보고, **"두 번째 자리는 4다!"** 라고 확신합니다.

이 과정을 반복하면 결국 전체 비밀번호 `8421`을 알아낼 수 있습니다.

## 3. 타이밍 공격 대응 방법

타이밍 공격을 막는 핵심 원칙은 간단합니다. **"연산 시간이 비밀 정보에 따라 달라지지 않게 만드는 것"**입니다. 즉, 입력값이 올바르든 틀리든 항상 동일한 시간(또는 거의 동일한 시간)이 걸리도록 만들어야 합니다.

### **방법 1: 상수 시간 비교 (Constant-Time Comparison) - 가장 강력한 방법**

'상수 시간 비교'는 문자열 비교 시, 중간에 틀린 부분을 발견하더라도 **절대 중간에 멈추지 않고, 의도적으로 모든 문자를 끝까지 비교**하는 방식입니다.

```python
# 타이밍 공격에 안전한 코드
import hmac

def secure_compare(user_input, secret_pin):
  # hmac.compare_digest는 파이썬이 제공하는 상수 시간 비교 함수
  # 이 함수는 입력값의 길이가 달라도 항상 안전하게 비교를 수행
  return hmac.compare_digest(user_input.encode(), secret_pin.encode())

# 직접 구현한다면 이런 원리입니다 (라이브러리 사용을 권장)
def constant_time_manual_compare(user_input, secret_pin):
  # 길이가 다를 경우를 대비해 해시 처리 후 비교하는 것이 더 안전하지만,
  # 원리 설명을 위해 단순화합니다.
  if len(user_input) != len(secret_pin):
    # 길이가 달라도 즉시 반환하지 않고, 임의의 값과 비교하여 시간 흐름을 비슷하게 맞춤
    hmac.compare_digest(user_input.encode(), user_input.encode())
    return False

  result = 0
  for x, y in zip(user_input, secret_pin):
    # 비트 XOR 연산을 통해 차이를 누적
    # result가 0이면 동일, 0이 아니면 차이가 있음
    result |= ord(x) ^ ord(y)

  return result == 0
```

- **핵심:** `hmac.compare_digest`와 같은 전문 라이브러리를 사용하는 것이 가장 안전하고 확실합니다. 직접 구현하는 것은 또 다른 실수를 유발할 수 있습니다.
- **원리:** 중간에 틀리더라도 루프를 끝까지 돌고, 비트 연산을 통해 차이점을 누적시킨 뒤 최종 결과만으로 성공/실패를 판단합니다. 이로 인해 모든 비교 연산은 거의 동일한 시간을 소요하게 됩니다.

### **방법 2: 임의 지연 추가 (Adding Random Delay)**

모든 요청 처리에 임의의 시간(e.g., 1~100ms)만큼 `sleep`을 추가하는 방식입니다.

- **장점:** 구현이 비교적 간단합니다.
- **단점:** 완벽한 방어책이 아닙니다. 공격자는 **더 많은 샘플을 수집하고 통계 처리**하여 임의의 지연 값(노이즈)을 평균 내어 제거하고, 원래의 미세한 시간 차이를 결국 찾아낼 수 있습니다. 공격을 _어렵게_ 만들 뿐, _불가능하게_ 만들지는 못합니다.

결론적으로, 비밀번호, API 키, 암호 토큰 등 보안에 민감한 데이터를 비교할 때는 **반드시 언어나 프레임워크가 제공하는 상수 시간 비교 함수를 사용**하는 것이 보안 표준입니다.
